From b69e9b2180b4a50adabec571e9ac9569d9287208 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Wed, 25 Feb 2015 10:50:59 +0000
Subject: [PATCH] check if reads were successful
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-on: https://gerrit.libreoffice.org/14631
Reviewed-by: Caol√°n McNamara <caolanm@redhat.com>
Tested-by: Caol√°n McNamara <caolanm@redhat.com>
(cherry picked from commit f974db5d89eacf0c23e303c22c62972014e9db16)

Conflicts:
	hwpfilter/source/hiodev.cxx
	hwpfilter/source/hiodev.h
	hwpfilter/source/hwpfile.cxx

Change-Id: I69ab0ca9c017c9a1c10d18fd850f32a92c641d12
Reviewed-on: https://gerrit.libreoffice.org/14654
Tested-by: Michael Stahl <mstahl@redhat.com>
Reviewed-by: Michael Stahl <mstahl@redhat.com>

Conflicts:
	hwpfilter/source/drawdef.h
	hwpfilter/source/hbox.h
	hwpfilter/source/hinfo.cxx
	hwpfilter/source/hiodev.h
	hwpfilter/source/hwpfile.cxx
	hwpfilter/source/hwpread.cxx

Conflicts:
	helpcontent2
	hwpfilter/source/hpara.cxx
	hwpfilter/source/hwpfile.cxx
	translations
---
 hwpfilter/source/drawdef.h   |  12 +-
 hwpfilter/source/drawing.h   | 281 +++++++++++++++++++++++++++----------------
 hwpfilter/source/hbox.h      |   4 +-
 hwpfilter/source/hinfo.cxx   | 118 +++++++++++++-----
 hwpfilter/source/hiodev.cxx  | 117 ++++++++++++------
 hwpfilter/source/hiodev.h    |  24 ++--
 hwpfilter/source/hpara.cxx   |  35 ++++--
 hwpfilter/source/htags.h     |   2 +-
 hwpfilter/source/hwpfile.cxx |  85 ++++++++-----
 hwpfilter/source/hwpfile.h   |  10 +-
 hwpfilter/source/hwplib.h    |  11 --
 hwpfilter/source/hwpread.cxx |  71 ++++++-----
 12 files changed, 489 insertions(+), 281 deletions(-)

diff --git a/hwpfilter/source/drawdef.h b/hwpfilter/source/drawdef.h
index 5c0423c..82bb695 100644
--- a/hwpfilter/source/drawdef.h
+++ b/hwpfilter/source/drawdef.h
@@ -86,11 +86,11 @@ struct BAREHWPDOProperty
     int line_pstyle;
     int line_hstyle;
     int line_tstyle;
-    DWORD line_color;
+    unsigned int line_color;
     hunit line_width;
-    DWORD fill_color;
+    unsigned int fill_color;
     uint pattern_type;
-    DWORD pattern_color;
+    unsigned int pattern_color;
     hunit hmargin;
     hunit vmargin;
     uint flag;
@@ -139,11 +139,11 @@ struct HWPDOProperty
     int line_pstyle; /* º± ¡ﬂ∞£ ∏æÁ */
     int line_hstyle; /* ≥° »≠ªÏ«• ∏æÁ */
     int line_tstyle; /* Ω√¿€ ∏æÁ */
-    DWORD line_color;
+    unsigned int line_color;
     hunit line_width;
-    DWORD fill_color;
+    unsigned int fill_color;
     uint pattern_type;
-    DWORD pattern_color;
+    unsigned int pattern_color;
     hunit hmargin;
     hunit vmargin;
     uint flag;
diff --git a/hwpfilter/source/drawing.h b/hwpfilter/source/drawing.h
index 83d342e..4a40c7b 100644
--- a/hwpfilter/source/drawing.h
+++ b/hwpfilter/source/drawing.h
@@ -132,7 +132,6 @@ inline bool HAS_PAT(HWPDrawingObject * hdo)
         HAVE_GRADATION(hdo) || HAVE_BITMAP_PATTERN(hdo);
 }
 
-
 static void SetHdoParallRgn(HWPDrawingObject * hdo, int width, int height)
 {
     hdo->property.parall.pt[0].x = 0;
@@ -143,37 +142,37 @@ static void SetHdoParallRgn(HWPDrawingObject * hdo, int width, int height)
     hdo->property.parall.pt[2].y = height;
 }
 
-
 static bool SkipPrivateBlock(int type)
 {
     int n;
 
     if (type == OBJRET_FILE_NO_PRIVATE_BLOCK)
     {
-        n = hmem->read4b();
+        if (!hmem->read4b(n))
+            return false;
         if (hmem->state() || hmem->skipBlock(n) != n)
             return false;
     }
-    n = hmem->read4b();
+    if (!hmem->read4b(n))
+        return false;
     if (hmem->state())
         return false;
     return hmem->skipBlock(n) == n;
 }
 
-
 static int SizeExpected;
 static int SizeRead;
 
 static int ReadSizeField(int size)
 {
     SizeExpected = size;
-    SizeRead = hmem->read4b();
+    if (!hmem->read4b(SizeRead))
+        return -1;
     if (hmem->state())
         return -1;
     return SizeRead;
 }
 
-
 static bool SkipUnusedField(void)
 {
     return (SizeExpected < SizeRead) ?
@@ -187,62 +186,93 @@ static bool SkipUnusedField(void)
 #define HDOFILE_HAS_NEXT    0x01
 #define HDOFILE_HAS_CHILD   0x02
 
-static bool LoadCommonHeader(HWPDrawingObject * hdo, WORD * link_info)
+static bool LoadCommonHeader(HWPDrawingObject * hdo, unsigned short * link_info)
 {
     uint size, common_size;
 
-     if( !hmem )
-         return FALSE;
-    size = hmem->read4b();
+    if (!hmem)
+        return false;
+    if (!hmem->read4b(size))
+        return false;
     if (hmem->state())
-    {
-        return FALSE;
-    }
+        return false;
     if (size < HDOFILE_COMMON_SIZE)
-    {
-        return FALSE;
-    }
+        return false;
 
     common_size = HDOFILE_COMMON_SIZE;
-    hdo->type = hmem->read2b();
-    *link_info = sal::static_int_cast<WORD>(hmem->read2b());
-    hdo->offset.x = hmem->read4b();
-    hdo->offset.y = hmem->read4b();
-    hdo->extent.w = hmem->read4b();
-    hdo->extent.h = hmem->read4b();
-    hdo->offset2.x = hmem->read4b();
-    hdo->offset2.y = hmem->read4b();
+    unsigned short tmp16;
+    if (!hmem->read2b(tmp16))
+        return false;
+    hdo->type = tmp16;
+    if (!hmem->read2b(tmp16))
+        return false;
+    *link_info = tmp16;
+    if (!hmem->read4b(hdo->offset.x))
+        return false;
+    if (!hmem->read4b(hdo->offset.y))
+        return false;
+    if (!hmem->read4b(hdo->extent.w))
+        return false;
+    if (!hmem->read4b(hdo->extent.h))
+        return false;
+    if (!hmem->read4b(hdo->offset2.x))
+        return false;
+    if (!hmem->read4b(hdo->offset2.y))
+        return false;
 
     if (hmem->state())
-        return FALSE;
+        return false;
 
-    hdo->vrect.x = hmem->read4b();
-    hdo->vrect.y = hmem->read4b();
-    hdo->vrect.w = hmem->read4b();
-    hdo->vrect.h = hmem->read4b();
+    if (!hmem->read4b(hdo->vrect.x))
+        return false;
+    if (!hmem->read4b(hdo->vrect.y))
+        return false;
+    if (!hmem->read4b(hdo->vrect.w))
+        return false;
+    if (!hmem->read4b(hdo->vrect.h))
+        return false;
 
 // read bare property 44 bytes
-    hdo->property.line_pstyle = hmem->read4b();
-    hdo->property.line_hstyle = hmem->read4b();
-    hdo->property.line_tstyle = hmem->read4b();
-    hdo->property.line_color = hmem->read4b();
-    hdo->property.line_width = (hunit) hmem->read4b();
-    hdo->property.fill_color = hmem->read4b();
-    hdo->property.pattern_type = hmem->read4b();
-    hdo->property.pattern_color = hmem->read4b();
-    hdo->property.hmargin = (hunit) hmem->read4b();
-    hdo->property.vmargin = (hunit) hmem->read4b();
-    hdo->property.flag = hmem->read4b();
-// read ratation property 32 bytes
+    if (!hmem->read4b(hdo->property.line_pstyle))
+        return false;
+    if (!hmem->read4b(hdo->property.line_hstyle))
+        return false;
+    if (!hmem->read4b(hdo->property.line_tstyle))
+        return false;
+    if (!hmem->read4b(hdo->property.line_color))
+        return false;
+    unsigned int tmp32;
+    if (!hmem->read4b(tmp32))
+        return false;
+    hdo->property.line_width = static_cast<hunit>(tmp32);
+    if (!hmem->read4b(hdo->property.fill_color))
+        return false;
+    if (!hmem->read4b(hdo->property.pattern_type))
+        return false;
+    if (!hmem->read4b(hdo->property.pattern_color))
+        return false;
+    if (!hmem->read4b(tmp32))
+        return false;
+    hdo->property.hmargin = static_cast<hunit>(tmp32);
+    if (!hmem->read4b(tmp32))
+        return false;
+    hdo->property.vmargin = static_cast<hunit>(tmp32);
+    if (!hmem->read4b(hdo->property.flag))
+        return false;
+// read rotation property 32 bytes
     if ((size >= common_size + 32)
         && (hdo->property.flag & HWPDO_FLAG_ROTATION))
     {
-        hdo->property.rot_originx = hmem->read4b();
-        hdo->property.rot_originy = hmem->read4b();
-        for (int ii = 0; ii < 3; ii++)
+        if (!hmem->read4b(hdo->property.rot_originx))
+            return false;
+        if (!hmem->read4b(hdo->property.rot_originy))
+            return false;
+        for (int ii = 0; ii < 3; ++ii)
         {
-            hdo->property.parall.pt[ii].x = hmem->read4b();
-            hdo->property.parall.pt[ii].y = hmem->read4b();
+            if (!hmem->read4b(hdo->property.parall.pt[ii].x))
+                return false;
+            if (!hmem->read4b(hdo->property.parall.pt[ii].y))
+                return false;
         }
         common_size += 32;
     }
@@ -253,13 +283,20 @@ static bool LoadCommonHeader(HWPDrawingObject * hdo, WORD * link_info)
     if ((size >= common_size + 28) &&
         (hdo->property.flag & HWPDO_FLAG_GRADATION))
     {
-        hdo->property.fromcolor = hmem->read4b();
-        hdo->property.tocolor = hmem->read4b();
-        hdo->property.gstyle = hmem->read4b();
-        hdo->property.angle = hmem->read4b();
-        hdo->property.center_x = hmem->read4b();
-        hdo->property.center_y = hmem->read4b();
-        hdo->property.nstep = hmem->read4b();
+        if (!hmem->read4b(hdo->property.fromcolor))
+            return false;
+        if (!hmem->read4b(hdo->property.tocolor))
+            return false;
+        if (!hmem->read4b(hdo->property.gstyle))
+            return false;
+        if (!hmem->read4b(hdo->property.angle))
+            return false;
+        if (!hmem->read4b(hdo->property.center_x))
+            return false;
+        if (!hmem->read4b(hdo->property.center_y))
+            return false;
+        if (!hmem->read4b(hdo->property.nstep))
+            return false;
         common_size += 28;
     }
 
@@ -267,54 +304,67 @@ static bool LoadCommonHeader(HWPDrawingObject * hdo, WORD * link_info)
     if ((size >= common_size + 278) && \
         (hdo->property.flag & HWPDO_FLAG_BITMAP))
     {
-        hdo->property.offset1.x = hmem->read4b();
-        hdo->property.offset1.y = hmem->read4b();
-        hdo->property.offset2.x = hmem->read4b();
-        hdo->property.offset2.y = hmem->read4b();
+        if (!hmem->read4b(hdo->property.offset1.x))
+            return false;
+        if (!hmem->read4b(hdo->property.offset1.y))
+            return false;
+        if (!hmem->read4b(hdo->property.offset2.x))
+            return false;
+        if (!hmem->read4b(hdo->property.offset2.y))
+            return false;
         if (!hmem->readBlock(hdo->property.szPatternFile, 261))
-            return FALSE;
-        hdo->property.pictype = sal::static_int_cast<char>(hmem->read1b());
+            return false;
+        if (!hmem->read1b(hdo->property.pictype))
+            return false;
         common_size += 278;
     }
      if( ( size >= common_size + 3 ) && ( hdo->property.flag & HWPDO_FLAG_WATERMARK ) )
      //if( ( size >= common_size ) && ( hdo->property.flag >> 20 & 0x01 ) )
      {
-          if( size - common_size >= 5 )
-              hmem->skipBlock( 2 );
-         hdo->property.luminance = hmem->read1b();
-         hdo->property.contrast = hmem->read1b();
-         hdo->property.greyscale = hmem->read1b();
-         common_size += 5;
-     }
-    else{
-         hdo->property.luminance = 0;
-         hdo->property.contrast = 0;
-         hdo->property.greyscale = 0;
+        if (size - common_size >= 5)
+            hmem->skipBlock(2);
+        unsigned char tmp8;
+        if (!hmem->read1b(tmp8))
+            return false;
+        hdo->property.luminance = tmp8;
+        if (!hmem->read1b(tmp8))
+            return false;
+        hdo->property.contrast = tmp8;
+        if (!hmem->read1b(tmp8))
+            return false;
+        hdo->property.greyscale = tmp8;
+
+        common_size += 5;
+    }
+    else
+    {
+        hdo->property.luminance = 0;
+        hdo->property.contrast = 0;
+        hdo->property.greyscale = 0;
     }
-     hdo->property.pPara = 0L;
+    hdo->property.pPara = 0L;
 
-     if( ( size > common_size ) && (hdo->property.flag & HWPDO_FLAG_AS_TEXTBOX) )
-     {
-          hmem->skipBlock(8);
-          hdo->property.pPara = LoadParaList();
-          if( hdo->property.pPara )
-                return TRUE;
-          else
-                return FALSE;
+    if( ( size > common_size ) && (hdo->property.flag & HWPDO_FLAG_AS_TEXTBOX) )
+    {
+        hmem->skipBlock(8);
+        hdo->property.pPara = LoadParaList();
+        if( hdo->property.pPara )
+            return true;
+        else
+            return false;
      }
 
-     if( size <= common_size )
-          return TRUE;
+     if (size <= common_size)
+          return true;
      return hmem->skipBlock(size - common_size ) != 0;
 }
 
-
 static HWPDrawingObject *LoadDrawingObject(void)
 {
     HWPDrawingObject *hdo, *head, *prev;
     int res;
 
-    WORD link_info;
+    unsigned short link_info;
 
     head = prev = NULL;
     do
@@ -373,6 +423,11 @@ static HWPDrawingObject *LoadDrawingObject(void)
 
     if (hdo != NULL)
     {
+        if (hdo->type < 0 || hdo->type >= HWPDO_NITEMS)
+        {
+            hdo->type = HWPDO_RECT;
+        }
+
         HWPDOFunc(hdo, OBJFUNC_FREE, NULL, 0);
         delete hdo;
     }
@@ -388,17 +443,25 @@ static HWPDrawingObject *LoadDrawingObject(void)
 
 static bool LoadDrawingObjectBlock(Picture * pic)
 {
-    int size = hmem->read4b();
+    int size;
+    if (!hmem->read4b(size))
+        return false;
 
     if (hmem->state() || size < HDOFILE_HEADER_SIZE)
         return false;
 
-    pic->picinfo.picdraw.zorder = hmem->read4b();
-    pic->picinfo.picdraw.mbrcnt = hmem->read4b();
-    pic->picinfo.picdraw.vrect.x = hmem->read4b();
-    pic->picinfo.picdraw.vrect.y = hmem->read4b();
-    pic->picinfo.picdraw.vrect.w = hmem->read4b();
-    pic->picinfo.picdraw.vrect.h = hmem->read4b();
+    if (!hmem->read4b(pic->picinfo.picdraw.zorder))
+        return false;
+    if (!hmem->read4b(pic->picinfo.picdraw.mbrcnt))
+        return false;
+    if (!hmem->read4b(pic->picinfo.picdraw.vrect.x))
+        return false;
+    if (!hmem->read4b(pic->picinfo.picdraw.vrect.y))
+        return false;
+    if (!hmem->read4b(pic->picinfo.picdraw.vrect.w))
+        return false;
+    if (!hmem->read4b(pic->picinfo.picdraw.vrect.h))
+        return false;
 
     if (size > HDOFILE_HEADER_SIZE &&
         !hmem->skipBlock(size - HDOFILE_HEADER_SIZE))
@@ -410,9 +473,7 @@ static bool LoadDrawingObjectBlock(Picture * pic)
     return true;
 }
 
-
 // object manipulation function
-
 static int
 HWPDODefaultFunc(int , HWPDrawingObject * , int cmd, void *, int)
 {
@@ -421,7 +482,6 @@ HWPDODefaultFunc(int , HWPDrawingObject * , int cmd, void *, int)
     return true;
 }
 
-
 static int
 HWPDOLineFunc(int type, HWPDrawingObject * hdo, int cmd, void *argp, int argv)
 {
@@ -431,7 +491,8 @@ HWPDOLineFunc(int type, HWPDrawingObject * hdo, int cmd, void *argp, int argv)
         case OBJFUNC_LOAD:
             if (ReadSizeField(4) < 4)
                 return OBJRET_FILE_ERROR;
-            hdo->u.line_arc.flip = hmem->read4b();
+            if (!hmem->read4b(hdo->u.line_arc.flip))
+                return OBJRET_FILE_ERROR;
             if (hmem->state())
                 return OBJRET_FILE_ERROR;
             if (!SkipUnusedField())
@@ -474,11 +535,14 @@ int cmd, void *argp, int argv)
         case OBJFUNC_LOAD:
             if (ReadSizeField(16) < 16)
                 return OBJRET_FILE_ERROR;
-            hdo->u.arc.radial[0].x = hmem->read4b();
-            hdo->u.arc.radial[0].y = hmem->read4b();
-            hdo->u.arc.radial[1].x = hmem->read4b();
-            hdo->u.arc.radial[1].y = hmem->read4b();
-
+            if (!hmem->read4b(hdo->u.arc.radial[0].x))
+                return OBJRET_FILE_ERROR;
+            if (!hmem->read4b(hdo->u.arc.radial[0].y))
+                return OBJRET_FILE_ERROR;
+            if (!hmem->read4b(hdo->u.arc.radial[1].x))
+                return OBJRET_FILE_ERROR;
+            if (!hmem->read4b(hdo->u.arc.radial[1].y))
+                return OBJRET_FILE_ERROR;
             if (ReadSizeField(0) < 0)
                 return OBJRET_FILE_ERROR;
             break;
@@ -499,7 +563,8 @@ HWPDOArcFunc(int type, HWPDrawingObject * hdo, int cmd, void *argp, int argv)
         case OBJFUNC_LOAD:
             if (ReadSizeField(4) < 4)
                 return OBJRET_FILE_ERROR;
-            hdo->u.line_arc.flip = hmem->read4b();
+            if (!hmem->read4b(hdo->u.line_arc.flip))
+                return OBJRET_FILE_ERROR;
             if (hmem->state())
                 return OBJRET_FILE_ERROR;
             if (!SkipUnusedField())
@@ -540,7 +605,8 @@ int cmd, void *argp, int argv)
             hdo->u.freeform.pt = 0;
             if (ReadSizeField(4) < 4)
                 return OBJRET_FILE_ERROR;
-            hdo->u.freeform.npt = hmem->read4b();
+            if (!hmem->read4b(hdo->u.freeform.npt))
+                return OBJRET_FILE_ERROR;
             if (hmem->state())
                 return OBJRET_FILE_ERROR;
             if (!SkipUnusedField())
@@ -559,11 +625,16 @@ int cmd, void *argp, int argv)
                     hdo->u.freeform.npt = 0;
                     return OBJRET_FILE_ERROR;
                 }
-                for (int ii = 0; ii < hdo->u.freeform.npt; ii++)
+                for (int ii = 0; ii < hdo->u.freeform.npt; ++ii)
                 {
-                    hdo->u.freeform.pt[ii].x = hmem->read4b();
-                    hdo->u.freeform.pt[ii].y = hmem->read4b();
+                    bool bFailure = false;
+                    if (!hmem->read4b(hdo->u.freeform.pt[ii].x))
+                        bFailure = true;
+                    if (!hmem->read4b(hdo->u.freeform.pt[ii].y))
+                        bFailure = true;
                     if (hmem->state())
+                        bFailure = true;
+                    if (bFailure)
                     {
                         delete[]hdo->u.freeform.pt;
                         hdo->u.freeform.npt = 0;
diff --git a/hwpfilter/source/hbox.h b/hwpfilter/source/hbox.h
index 3ada510..34b418a 100644
--- a/hwpfilter/source/hbox.h
+++ b/hwpfilter/source/hbox.h
@@ -80,7 +80,7 @@ struct HBox
  */
 struct SkipData: public HBox
 {
-    ulong data_block_len;
+    uint data_block_len;
     hchar dummy;
     char  *data_block;
 
@@ -627,7 +627,7 @@ struct Picture: public FBox
  * follow_block_size is the size information of the Drawing object of hwp.
  * It's value is greater than 0 if the pictype is PICTYPE_DRAW.
  */
-    ulong     follow_block_size;                  /* √ﬂ∞°¡§∫∏ ±Ê¿Ã. */
+    uint      follow_block_size;                  /* Ï∂îÍ∞ÄÏ†ïÎ≥¥ Í∏∏Ïù¥. */
     short     dummy1;                             // to not change structure size */
     short     dummy2;                             // to not change structure size */
     uchar     reserved1;
diff --git a/hwpfilter/source/hinfo.cxx b/hwpfilter/source/hinfo.cxx
index fb57e49..7837379 100644
--- a/hwpfilter/source/hinfo.cxx
+++ b/hwpfilter/source/hinfo.cxx
@@ -75,20 +75,39 @@ bool HWPInfo::Read(HWPFile & hwpf)
     hwpf.Read1b(&paper.paper_direction, 1);       /* øÎ¡ˆ πÊ«‚ */
 
 // paper geometry information
-    paper.paper_height = (short) hwpf.Read2b();   /* øÎ¡ˆ ±Ê¿Ã */
-    paper.paper_width = (short) hwpf.Read2b();    /* øÎ¡ˆ ≥ ∫Ò */
-    paper.top_margin = (short) hwpf.Read2b();     /* ¿ß¬  ø©πÈ */
-    paper.bottom_margin = (short) hwpf.Read2b();  /* æ∆∑°¬  ø©πÈ */
-    paper.left_margin = (short) hwpf.Read2b();    /* øﬁ¬  ø©πÈ */
-    paper.right_margin = (short) hwpf.Read2b();   /* ø¿∏•¬  ø©πÈ */
-    paper.header_length = (short) hwpf.Read2b();  /* ∏”∏Æ∏ª ±Ê¿Ã */
-    paper.footer_length = (short) hwpf.Read2b();  /* ≤ø∏Æ∏ª ±Ê¿Ã */
-    paper.gutter_length = (short) hwpf.Read2b();  /* ¡¶∫ªø©πÈ */
-    hwpf.Read2b(&readonly, 1);                    /* øπæ‡ */
-    hwpf.Read1b(reserved1, 4);                    /* øπæ‡ */
-    hwpf.Read1b(&chain_info.chain_page_no, 1);    /* ¬  π¯»£ ø¨∞· 1-ø¨∞·, 0-ªı∑ŒΩ√¿€ (ø¨∞·¿Œº‚ø°º≠ ªÁøÎ) */
-    hwpf.Read1b(&chain_info.chain_footnote_no, 1);/* ∞¢¡÷π¯»£ ø¨∞· 1-ø¨∞· 0-ªı∑ŒΩ√¿€ */
-                                                  /* ø¨∞·¿Œº‚«“ ∆ƒ¿œ¿« ¿Ã∏ß */
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.paper_height = tmp16;                   /* Ïö©ÏßÄ Í∏∏Ïù¥ */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.paper_width = tmp16;                    /* Ïö©ÏßÄ ÎÑàÎπÑ */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.top_margin = tmp16;                     /* ÏúÑÏ™Ω Ïó¨Î∞± */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.bottom_margin = tmp16;                  /* ÏïÑÎûòÏ™Ω Ïó¨Î∞± */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.left_margin = tmp16;                    /* ÏôºÏ™Ω Ïó¨Î∞± */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.right_margin = tmp16;                   /* Ïò§Î•∏Ï™Ω Ïó¨Î∞± */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.header_length = tmp16;                  /* Î®∏Î¶¨Îßê Í∏∏Ïù¥ */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.footer_length = tmp16;                  /* Íº¨Î¶¨Îßê Í∏∏Ïù¥ */
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    paper.gutter_length = tmp16;                  /* Ï†úÎ≥∏Ïó¨Î∞± */
+    hwpf.Read2b(&readonly, 1);                    /* ÏòàÏïΩ */
+    hwpf.Read1b(reserved1, 4);                    /* ÏòàÏïΩ */
+    hwpf.Read1b(&chain_info.chain_page_no, 1);    /* Ï™Ω Î≤àÌò∏ Ïó∞Í≤∞ 1-Ïó∞Í≤∞, 0-ÏÉàÎ°úÏãúÏûë (Ïó∞Í≤∞Ïù∏ÏáÑÏóêÏÑú ÏÇ¨Ïö©) */
+    hwpf.Read1b(&chain_info.chain_footnote_no, 1);/* Í∞ÅÏ£ºÎ≤àÌò∏ Ïó∞Í≤∞ 1-Ïó∞Í≤∞ 0-ÏÉàÎ°úÏãúÏûë */
+                                                  /* Ïó∞Í≤∞Ïù∏ÏáÑÌï† ÌååÏùºÏùò Ïù¥Î¶Ñ */
     hwpf.Read1b(chain_info.chain_filename, CHAIN_MAX_PATH);
 
     hwpf.Read1b(annotation, ANNOTATION_LEN);      /* µ°∫Ÿ¿Ã¥¬ ∏ª ( ∆ƒ¿œ ¿˙¿Â«“ ∂ß µ°∫Ÿ¿Ã¥¬ ∏ªø° ¡ˆ¡§«— ≥ªøÎ ) */
@@ -97,16 +116,27 @@ bool HWPInfo::Read(HWPFile & hwpf)
     hwpf.Read2b(&beginpagenum,1);                 /* ∆‰¿Ã¡ˆΩ√¿€π¯»£ */
 
 // footnote
-    hwpf.Read2b(&beginfnnum,1);                   /* ∞¢¡÷ Ω√¿€π¯»£ */
-    hwpf.Read2b(&countfn,1);                      /* ∞¢¡÷ ∞πºˆ */
-    splinetext = (short) hwpf.Read2b();
-    splinefn = (short) hwpf.Read2b();
-    spfnfn = (short) hwpf.Read2b();
+    hwpf.Read2b(&beginfnnum,1);                   /* Í∞ÅÏ£º ÏãúÏûëÎ≤àÌò∏ */
+    hwpf.Read2b(&countfn,1);                      /* Í∞ÅÏ£º Í∞ØÏàò */
+
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    splinetext = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    splinefn = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    spfnfn = tmp16;
     hwpf.Read1b(&fnchar, 1);
     hwpf.Read1b(&fnlinetype, 1);
 // border layout
     for (int ii = 0; ii < 4; ++ii)
-        bordermargin[ii] = (short) hwpf.Read2b();
+    {
+        if (!hwpf.Read2b(tmp16))
+            return false;
+        bordermargin[ii] = tmp16;
+    }
     hwpf.Read2b(&borderline, 1);
 
     hwpf.Read1b(&empty_line_hide, 1);
@@ -161,12 +191,23 @@ bool HWPSummary::Read(HWPFile & hwpf)
 
 bool ParaShape::Read(HWPFile & hwpf)
 {
-     pagebreak = 0;
-    left_margin = (short) hwpf.Read2b();
-    right_margin = (short) hwpf.Read2b();
-    indent = (short) hwpf.Read2b();
-    lspacing = (short) hwpf.Read2b();
-    pspacing_next = (short) hwpf.Read2b();
+    pagebreak = 0;
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    left_margin = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    right_margin = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    indent = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    lspacing = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    pspacing_next = tmp16;
 
     hwpf.Read1b(&condense, 1);
     hwpf.Read1b(&arrange_type, 1);
@@ -174,17 +215,27 @@ bool ParaShape::Read(HWPFile & hwpf)
     {
         hwpf.Read1b(&tabs[ii].type, 1);
         hwpf.Read1b(&tabs[ii].dot_continue, 1);
-        tabs[ii].position = (short) hwpf.Read2b();
+        if (!hwpf.Read2b(tmp16))
+            return false;
+        tabs[ii].position = tmp16;
     }
     hwpf.Read1b(&coldef.ncols, 1);
     hwpf.Read1b(&coldef.separator, 1);
-    coldef.spacing = (short) hwpf.Read2b();
-    coldef.columnlen = (short) hwpf.Read2b();
-    coldef.columnlen0 = (short) hwpf.Read2b();
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    coldef.spacing = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    coldef.columnlen = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    coldef.columnlen0 = tmp16;
     hwpf.Read1b(&shade, 1);
     hwpf.Read1b(&outline, 1);
     hwpf.Read1b(&outline_continue, 1);
-    pspacing_prev = (short) hwpf.Read2b();
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    pspacing_prev = tmp16;
 
     hwpf.Read1b(reserved, 2);
     return (!hwpf.State());
@@ -193,7 +244,10 @@ bool ParaShape::Read(HWPFile & hwpf)
 
 bool CharShape::Read(HWPFile & hwpf)
 {
-    size = (short) hwpf.Read2b();
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    size = tmp16;
     hwpf.Read1b(font, NLanguage);
     hwpf.Read1b(ratio, NLanguage);
     hwpf.Read1b(space, NLanguage);
diff --git a/hwpfilter/source/hiodev.cxx b/hwpfilter/source/hiodev.cxx
index 0416a96..422eb06 100644
--- a/hwpfilter/source/hiodev.cxx
+++ b/hwpfilter/source/hiodev.cxx
@@ -80,14 +80,14 @@ int HIODev::read1b(void *ptr, int nmemb)
         return -1;
     for (ii = 0; ii < nmemb; ii++)
     {
-        p[ii] = sal::static_int_cast<uchar>(read1b());
+        if (!read1b(p[ii]))
+            break;
         if (state())
             break;
     }
     return ii;
 }
 
-
 int HIODev::read2b(void *ptr, int nmemb)
 {
     ushort *p = (ushort *) ptr;
@@ -97,24 +97,25 @@ int HIODev::read2b(void *ptr, int nmemb)
         return -1;
     for (ii = 0; ii < nmemb; ii++)
     {
-        p[ii] = sal::static_int_cast<uchar>(read2b());
+        if (!read2b(p[ii]))
+            break;
         if (state())
             break;
     }
     return ii;
 }
 
-
 int HIODev::read4b(void *ptr, int nmemb)
 {
-    ulong *p = (ulong *) ptr;
+    uint *p = (uint *) ptr;
     int ii;
 
     if (state())
         return -1;
     for (ii = 0; ii < nmemb; ii++)
     {
-        p[ii] = read4b();
+        if (!read4b(p[ii]))
+            break;
         if (state())
             break;
     }
@@ -195,39 +196,57 @@ bool HStreamIODev::setCompressed(bool flag)
 
 #define GZREAD(ptr,len) (_gzfp?gz_read(_gzfp,ptr,len):0)
 
-int HStreamIODev::read1b()
+bool HStreamIODev::read1b(unsigned char &out)
 {
     int res = (compressed) ? GZREAD(rBuf, 1) : _stream.readBytes(rBuf, 1);
 
-    if (res <= 0)
-        return -1;
-    else
-        return (unsigned char) rBuf[0];
+    if (res < 1)
+        return false;
+
+    out = (unsigned char)rBuf[0];
+    return true;
 }
 
+bool HStreamIODev::read1b(char &out)
+{
+    unsigned char tmp8;
+    if (!read1b(tmp8))
+        return false;
+    out = tmp8;
+    return true;
+}
 
-int HStreamIODev::read2b()
+bool HStreamIODev::read2b(unsigned short &out)
 {
     int res = (compressed) ? GZREAD(rBuf, 2) : _stream.readBytes(rBuf, 2);
 
-    if (res <= 0)
-        return -1;
-    else
-        return ((unsigned char) rBuf[1] << 8 | (unsigned char) rBuf[0]);
-}
+    if (res < 2)
+        return false;
 
+    out = ((unsigned char) rBuf[1] << 8 | (unsigned char) rBuf[0]);
+    return true;
+}
 
-long HStreamIODev::read4b()
+bool HStreamIODev::read4b(unsigned int &out)
 {
     int res = (compressed) ? GZREAD(rBuf, 4) : _stream.readBytes(rBuf, 4);
 
-    if (res <= 0)
-        return -1;
-    else
-        return ((unsigned char) rBuf[3] << 24 | (unsigned char) rBuf[2] << 16 |
-            (unsigned char) rBuf[1] << 8 | (unsigned char) rBuf[0]);
+    if (res < 4)
+        return false;
+
+    out = ((unsigned char) rBuf[3] << 24 | (unsigned char) rBuf[2] << 16 |
+        (unsigned char) rBuf[1] << 8 | (unsigned char) rBuf[0]);
+    return true;
 }
 
+bool HStreamIODev::read4b(int &out)
+{
+    unsigned int tmp32;
+    if (!read4b(tmp32))
+        return false;
+    out = tmp32;
+    return true;
+}
 
 int HStreamIODev::readBlock(void *ptr, int size)
 {
@@ -239,7 +258,6 @@ int HStreamIODev::readBlock(void *ptr, int size)
     return count;
 }
 
-
 int HStreamIODev::skipBlock(int size)
 {
     if (compressed){
@@ -314,36 +332,56 @@ bool HMemIODev::setCompressed(bool )
     return false;
 }
 
-
-int HMemIODev::read1b()
+bool HMemIODev::read1b(unsigned char &out)
 {
     if (pos <= length)
-         return ptr[pos++];
-     else
-         return 0;
+    {
+        out = ptr[pos++];
+        return true;
+    }
+    return false;
 }
 
+bool HMemIODev::read1b(char &out)
+{
+    unsigned char tmp8;
+    if (!read1b(tmp8))
+        return false;
+    out = tmp8;
+    return true;
+}
 
-int HMemIODev::read2b()
+bool HMemIODev::read2b(unsigned short &out)
 {
     pos += 2;
     if (pos <= length)
-         return ptr[pos - 1] << 8 | ptr[pos - 2];
-     else
-         return 0;
+    {
+         out = ptr[pos - 1] << 8 | ptr[pos - 2];
+         return true;
+    }
+    return false;
 }
 
-
-long HMemIODev::read4b()
+bool HMemIODev::read4b(unsigned int &out)
 {
     pos += 4;
     if (pos <= length)
-         return DWORD(ptr[pos - 1] << 24 | ptr[pos - 2] << 16 |
-        ptr[pos - 3] << 8 | ptr[pos - 4]);
-     else
-         return 0;
+    {
+        out = static_cast<unsigned int>(ptr[pos - 1] << 24 | ptr[pos - 2] << 16 |
+                    ptr[pos - 3] << 8 | ptr[pos - 4]);
+        return true;
+    }
+    return false;
 }
 
+bool HMemIODev::read4b(int &out)
+{
+    unsigned int tmp32;
+    if (!read4b(tmp32))
+        return false;
+    out = tmp32;
+    return true;
+}
 
 int HMemIODev::readBlock(void *p, int size)
 {
@@ -354,7 +392,6 @@ int HMemIODev::readBlock(void *p, int size)
     return size;
 }
 
-
 int HMemIODev::skipBlock(int size)
 {
     if (length < pos + size)
diff --git a/hwpfilter/source/hiodev.h b/hwpfilter/source/hiodev.h
index f0fd1b1..638c875 100644
--- a/hwpfilter/source/hiodev.h
+++ b/hwpfilter/source/hiodev.h
@@ -59,9 +59,11 @@ class DLLEXPORT HIODev
 /* gzip routine wrapper */
         virtual bool setCompressed( bool ) = 0;
 
-        virtual int read1b() = 0;
-        virtual int read2b() = 0;
-        virtual long read4b() = 0;
+        virtual bool read1b(unsigned char &out) = 0;
+        virtual bool read1b(char &out) = 0;
+        virtual bool read2b(unsigned short &out) = 0;
+        virtual bool read4b(unsigned int &out) = 0;
+        virtual bool read4b(int &out) = 0;
         virtual int readBlock( void *ptr, int size ) = 0;
         virtual int skipBlock( int size ) = 0;
 
@@ -111,17 +113,19 @@ class HStreamIODev : public HIODev
  * Read one byte from stream
  */
         using HIODev::read1b;
-        virtual int read1b();
+        virtual bool read1b(unsigned char &out);
+        virtual bool read1b(char &out);
 /**
  * Read 2 bytes from stream
  */
         using HIODev::read2b;
-        virtual int read2b();
+        virtual bool read2b(unsigned short &out);
 /**
  * Read 4 bytes from stream
  */
         using HIODev::read4b;
-        virtual long read4b();
+        virtual bool read4b(unsigned int &out);
+        virtual bool read4b(int &out);
 /**
  * Read some bytes from stream to given pointer as amount of size
  */
@@ -157,11 +161,13 @@ class HMemIODev : public HIODev
 /* gzip routine wrapper */
         virtual bool setCompressed( bool );
         using HIODev::read1b;
-        virtual int read1b();
+        virtual bool read1b(unsigned char &out);
+        virtual bool read1b(char &out);
         using HIODev::read2b;
-        virtual int read2b();
+        virtual bool read2b(unsigned short &out);
         using HIODev::read4b;
-        virtual long read4b();
+        virtual bool read4b(unsigned int &out);
+        virtual bool read4b(int &out);
         virtual int readBlock( void *ptr, int size );
         virtual int skipBlock( int size );
     protected:
diff --git a/hwpfilter/source/hpara.cxx b/hwpfilter/source/hpara.cxx
index 756a9df..9143570 100644
--- a/hwpfilter/source/hpara.cxx
+++ b/hwpfilter/source/hpara.cxx
@@ -39,14 +39,28 @@
 
 bool LineInfo::Read(HWPFile & hwpf, HWPPara *pPara)
 {
-    pos = sal::static_int_cast<unsigned short>(hwpf.Read2b());
-    space_width = (short) hwpf.Read2b();
-    height = (short) hwpf.Read2b();
-// internal informations
-    pgy = (short) hwpf.Read2b();
-    sx = (short) hwpf.Read2b();
-    psx = (short) hwpf.Read2b();
-    pex = (short) hwpf.Read2b();
+    if (!hwpf.Read2b(pos))
+        return false;
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    space_width = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    height = tmp16;
+// internal information
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    pgy = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    sx = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    psx = tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    pex = tmp16;
     height_sp = 0;
 
     if( pex >> 15 & 0x01 )
@@ -212,7 +226,10 @@ ParaShape *HWPPara::GetParaShape(void)
 
 HBox *HWPPara::readHBox(HWPFile & hwpf)
 {
-    hchar hh = sal::static_int_cast<hchar>(hwpf.Read2b());
+    hchar hh;
+    if (!hwpf.Read2b(hh))
+        return 0;
+
     HBox *hbox = 0;
 
     if (hwpf.State() != HWP_NoError)
diff --git a/hwpfilter/source/htags.h b/hwpfilter/source/htags.h
index 21c610d..1158477 100644
--- a/hwpfilter/source/htags.h
+++ b/hwpfilter/source/htags.h
@@ -67,7 +67,7 @@ struct HyperText
 struct OlePicture
 {
     int   size;
-    ulong signature;
+    uint signature;
 #ifdef WIN32
      IStorage *pis;
 #else
diff --git a/hwpfilter/source/hwpfile.cxx b/hwpfilter/source/hwpfile.cxx
index 66e0eb9..4bc0511 100644
--- a/hwpfilter/source/hwpfile.cxx
+++ b/hwpfilter/source/hwpfile.cxx
@@ -145,44 +145,55 @@ int HWPFile::Open(HStream & stream)
     return HWP_NoError;
 }
 
-
 int HWPFile::State(void) const
 {
     return error_code;
 }
 
-
 int HWPFile::SetState(int errcode)
 {
     error_code = errcode;
     return error_code;
 }
 
-
-int HWPFile::Read1b(void)
+bool HWPFile::Read1b(unsigned char &out)
 {
-    return hiodev ? hiodev->read1b() : -1;
+    return hiodev ? hiodev->read1b(out) : false;
 }
 
-
-int HWPFile::Read2b(void)
+bool HWPFile::Read1b(char &out)
 {
-    return hiodev ? hiodev->read2b() : -1;
+    unsigned char tmp8;
+    if (!Read1b(tmp8))
+        return false;
+    out = tmp8;
+    return true;
 }
 
+bool HWPFile::Read2b(unsigned short &out)
+{
+    return hiodev ? hiodev->read2b(out) : false;
+}
 
-long HWPFile::Read4b(void)
+bool HWPFile::Read4b(unsigned int &out)
 {
-    return hiodev ? hiodev->read4b() : -1;
+    return hiodev ? hiodev->read4b(out) : false;
 }
 
+bool HWPFile::Read4b(int &out)
+{
+    unsigned int tmp32;
+    if (!Read4b(tmp32))
+        return false;
+    out = tmp32;
+    return true;
+}
 
 int HWPFile::Read1b(void *ptr, size_t nmemb)
 {
     return hiodev ? hiodev->read1b(ptr, nmemb) : 0;
 }
 
-
 int HWPFile::Read2b(void *ptr, size_t nmemb)
 {
     return hiodev ? hiodev->read2b(ptr, nmemb) : 0;
@@ -286,23 +297,23 @@ bool HWPFile::ReadParaList(LinkedList < HWPPara > &aplist, unsigned char flag)
     return true;
 }
 
-
-bool HWPFile::TagsRead(void)
+void HWPFile::TagsRead(void)
 {
-    ulong tag;
-    long size;
-
-    while (1)
+    while (true)
     {
-        tag = Read4b();
-        size = Read4b();
+        uint tag;
+        if (!Read4b(tag))
+            return;
+        uint size;
+        if (!Read4b(size))
+            return;
         if (size <= 0 && tag > 0){
             continue;
           }
 
         if (tag == FILETAG_END_OF_COMPRESSED ||
             tag == FILETAG_END_OF_UNCOMPRESSED)
-            return true;
+            return;
         switch (tag)
         {
             case FILETAG_EMBEDDED_PICTURE:
@@ -326,29 +337,40 @@ bool HWPFile::TagsRead(void)
                 if( (size % 617) != 0 )
                     SkipBlock( size );
                 else
-                    for( int i = 0 ; i < size/617 ; i++)
                 {
-                    HyperText *hypert = new HyperText;
-                    hypert->Read(*this);
-                    hyperlist.insert(hypert, -1);
+
+                    for( uint i = 0 ; i < size/617 ; i++)
+                    {
+                        HyperText *hypert = new HyperText;
+                        hypert->Read(*this);
+                        hyperlist.insert(hypert, -1);
+                    }
                 }
                 break;
             }
                 case 6:
                 {
                      ReadBlock(_hwpInfo.back_info.reserved1, 8);
-                     _hwpInfo.back_info.luminance = Read4b();
-                     _hwpInfo.back_info.contrast = Read4b();
-                     _hwpInfo.back_info.effect = sal::static_int_cast<char>(Read1b());
+                     if (!Read4b(_hwpInfo.back_info.luminance))
+                        return;
+                     if (!Read4b(_hwpInfo.back_info.contrast))
+                        return;
+                     if (!Read1b(_hwpInfo.back_info.effect))
+                        return;
                      ReadBlock(_hwpInfo.back_info.reserved2, 7);
                      ReadBlock(_hwpInfo.back_info.filename, 260);
                      ReadBlock(_hwpInfo.back_info.color, 3);
-                     unsigned short nFlag = sal::static_int_cast<unsigned short>(Read2b());
+                     unsigned short nFlag;
+                     if (!Read2b(nFlag))
+                        return;
                      _hwpInfo.back_info.flag = nFlag >> 8 ;
-                     int nRange = Read4b();
+                     int nRange;
+                     if (!Read4b(nRange))
+                        return;
                      _hwpInfo.back_info.range = nRange >> 24;
                      ReadBlock(_hwpInfo.back_info.reserved3, 27);
-                     _hwpInfo.back_info.size = Read4b();
+                     if (!Read4b(_hwpInfo.back_info.size))
+                        return;
 
                      _hwpInfo.back_info.data = new char[(unsigned int)_hwpInfo.back_info.size];
                      ReadBlock(_hwpInfo.back_info.data, _hwpInfo.back_info.size);
@@ -615,7 +637,8 @@ int HWPFile::compareParaShape(ParaShape *shape)
                 shape->outline == pshape->outline  &&
                      shape->pagebreak == pshape->pagebreak)
             {
-                    if( shape->cshape->size == pshape->cshape->size &&
+                    if( shape->cshape && pshape->cshape &&
+                         shape->cshape->size == pshape->cshape->size &&
                          shape->cshape->font[0] == pshape->cshape->font[0] &&
                          shape->cshape->ratio[0] == pshape->cshape->ratio[0] &&
                          shape->cshape->space[0] == pshape->cshape->space[0] &&
diff --git a/hwpfilter/source/hwpfile.h b/hwpfilter/source/hwpfile.h
index 8f71c4a..711d077 100644
--- a/hwpfilter/source/hwpfile.h
+++ b/hwpfilter/source/hwpfile.h
@@ -133,15 +133,17 @@ class DLLEXPORT HWPFile
 /**
  * Reads one byte from HIODev
  */
-        int Read1b( void );
+        bool Read1b(char &out);
+        bool Read1b(unsigned char &out);
 /**
  * Reads two byte from HIODev
  */
-        int Read2b( void );
+        bool Read2b(unsigned short &out);
 /**
  * Reads four byte from HIODev
  */
-        long Read4b( void );
+        bool Read4b(unsigned int &out);
+        bool Read4b(int &out);
 /**
  * Reads nmemb byte array from HIODev
  */
@@ -200,7 +202,7 @@ class DLLEXPORT HWPFile
 /**
  * Reads additional information like embeded image of hwp file from HIODev
  */
-        bool TagsRead(void);
+        void TagsRead();
 
         enum Paper
         {
diff --git a/hwpfilter/source/hwplib.h b/hwpfilter/source/hwplib.h
index 9b9f37e..7cd6ccf 100644
--- a/hwpfilter/source/hwplib.h
+++ b/hwpfilter/source/hwplib.h
@@ -44,22 +44,11 @@ typedef unsigned char       kchar;
 typedef unsigned char       echar;
 #endif                                            // _HCHAR_
 
-#if !defined(WIN32)
-#if !defined(_BOOL_T_) && !defined(OS2)
-typedef unsigned short  BOOL;
-#endif                                            /* _BOOL_T_ */
-typedef unsigned short  WORD;
-typedef int     SIZE;
-typedef unsigned long   DWORD;
-typedef long        LONG;
-#endif                                            /* WIN32 */
-
 #ifndef _UTYPE_
 #define _UTYPE_
 typedef unsigned char   uchar;
 typedef unsigned short  ushort;
 typedef unsigned int    uint;
-typedef unsigned long   ulong;
 #endif                                            /* _UTYPE_ */
 
 typedef ::std::basic_string<hchar> hchar_string;
diff --git a/hwpfilter/source/hwpread.cxx b/hwpfilter/source/hwpread.cxx
index 85eaa4c..35e3851 100644
--- a/hwpfilter/source/hwpread.cxx
+++ b/hwpfilter/source/hwpread.cxx
@@ -70,12 +70,12 @@ int SkipData::Read(HWPFile & hwpf)
 // Field code(5)
 int FieldCode::Read(HWPFile & hwpf)
 {
-    ulong size;
+    uint size;
     hchar dummy;
-    ulong len1;       /* hchar≈∏¿‘¿« πÆ¿⁄ø≠ ≈◊¿Ã≈Õ #1¿« ±Ê¿Ã */
-    ulong len2;       /* hchar≈∏¿‘¿« πÆ¿⁄ø≠ ≈◊¿Ã≈Õ #2¿« ±Ê¿Ã */
-    ulong len3;       /* hchar≈∏¿‘¿« πÆ¿⁄ø≠ ≈◊¿Ã≈Õ #3¿« ±Ê¿Ã */
-    ulong binlen;     /* ¿”¿« «¸Ωƒ¿« πŸ¿Ã≥ ∏Æ µ•¿Ã≈∏ ±Ê¿Ã */
+    uint len1;       /* hcharÌÉÄÏûÖÏùò Î¨∏ÏûêÏó¥ ÌÖåÏù¥ÌÑ∞ #1Ïùò Í∏∏Ïù¥ */
+    uint len2;       /* hcharÌÉÄÏûÖÏùò Î¨∏ÏûêÏó¥ ÌÖåÏù¥ÌÑ∞ #2Ïùò Í∏∏Ïù¥ */
+    uint len3;       /* hcharÌÉÄÏûÖÏùò Î¨∏ÏûêÏó¥ ÌÖåÏù¥ÌÑ∞ #3Ïùò Í∏∏Ïù¥ */
+    uint binlen;     /* ÏûÑÏùò ÌòïÏãùÏùò Î∞îÏù¥ÎÑàÎ¶¨ Îç∞Ïù¥ÌÉÄ Í∏∏Ïù¥ */
 
     hwpf.Read4b(&size, 1);
     hwpf.Read2b(&dummy, 1);
@@ -88,9 +88,9 @@ int FieldCode::Read(HWPFile & hwpf)
     hwpf.Read4b(&len3, 1);
     hwpf.Read4b(&binlen, 1);
 
-    ulong const len1_ = ((len1 > 1024) ? 1024 : len1) / sizeof(hchar);
-    ulong const len2_ = ((len2 > 1024) ? 1024 : len2) / sizeof(hchar);
-    ulong const len3_ = ((len3 > 1024) ? 1024 : len3) / sizeof(hchar);
+    uint const len1_ = ((len1 > 1024) ? 1024 : len1) / sizeof(hchar);
+    uint const len2_ = ((len2 > 1024) ? 1024 : len2) / sizeof(hchar);
+    uint const len3_ = ((len3 > 1024) ? 1024 : len3) / sizeof(hchar);
 
     str1 = new hchar[len1_ ? len1_ : 1];
     str2 = new hchar[len2_ ? len2_ : 1];
@@ -123,14 +123,14 @@ int FieldCode::Read(HWPFile & hwpf)
     return true;
 }
 
-
 // book mark(6)
 int Bookmark::Read(HWPFile & hwpf)
 {
     long len;
 
     hwpf.Read4b(&len, 1);
-    dummy = sal::static_int_cast<hchar>(hwpf.Read2b());
+    if (!hwpf.Read2b(dummy))
+        return false;
 
     if (!(len == 34))// 2 * (BMK_COMMENT_LEN + 1) + 2
      {
@@ -142,31 +142,28 @@ int Bookmark::Read(HWPFile & hwpf)
 
     hwpf.Read2b(id, BMK_COMMENT_LEN + 1);
     hwpf.Read2b(&type, 1);
-//return hwpf.Read2b(&type, 1);
-    return 1;
+    return true;
 }
 
-
 // date format(7)
-
 int DateFormat::Read(HWPFile & hwpf)
 {
     hwpf.Read2b(format, DATE_SIZE);
-    dummy = sal::static_int_cast<hchar>(hwpf.Read2b());
+    if (!hwpf.Read2b(dummy))
+        return false;
     if (!(hh == dummy && CH_DATE_FORM == dummy)){
         return hwpf.SetState(HWP_InvalidFileFormat);
      }
     return true;
 }
 
-
 // date code(8)
-
 int DateCode::Read(HWPFile & hwpf)
 {
     hwpf.Read2b(format, DATE_SIZE);
     hwpf.Read2b(date, 6);
-    dummy = sal::static_int_cast<hchar>(hwpf.Read2b());
+    if (!hwpf.Read2b(dummy))
+        return false;
     if (!(hh == dummy && CH_DATE_CODE == dummy)){
         return hwpf.SetState(HWP_InvalidFileFormat);
      }
@@ -174,30 +171,30 @@ int DateCode::Read(HWPFile & hwpf)
     return true;
 }
 
-
 // tab(9)
-
 int Tab::Read(HWPFile & hwpf)
 {
-    width = hwpf.Read2b();
-    leader = sal::static_int_cast<unsigned short>(hwpf.Read2b());
-    dummy = sal::static_int_cast<hchar>(hwpf.Read2b());
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    width = tmp16;
+    if (!hwpf.Read2b(leader))
+        return false;
+    if (!hwpf.Read2b(dummy))
+        return false;
     if (!(hh == dummy && CH_TAB == dummy)){
         return hwpf.SetState(HWP_InvalidFileFormat);
      }
     return true;
 }
 
-
 // tbox(10) TABLE BOX MATH BUTTON HYPERTEXT
-
 static void UpdateBBox(FBox * fbox)
 {
     fbox->boundsy = fbox->pgy;
     fbox->boundey = fbox->pgy + fbox->ys - 1;
 }
 
-
 void Cell::Read(HWPFile & hwpf)
 {
     hwpf.Read2b(&p, 1);
@@ -422,10 +419,19 @@ int Picture::Read(HWPFile & hwpf)
 
     hwpf.Read1b(&pictype, 1);                     /* ±◊∏≤¡æ∑˘ */
 
-    skip[0] = (short) hwpf.Read2b();              /* ±◊∏≤ø°º≠ Ω«¡¶ «•Ω√∏¶ Ω√¿€«“ ¿ßƒ° ∞°∑Œ */
-    skip[1] = (short) hwpf.Read2b();              /* ºº∑Œ */
-    scale[0] = (short) hwpf.Read2b();             /* »Æ¥Î∫Ò¿≤ : 0 ∞Ì¡§, ¿Ãø‹ ∆€ºæ∆Æ ¥‹¿ß ∞°∑Œ */
-    scale[1] = (short) hwpf.Read2b();             /* ºº∑Œ */
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))                      /* Í∑∏Î¶ºÏóêÏÑú Ïã§Ï†ú ÌëúÏãúÎ•º ÏãúÏûëÌï† ÏúÑÏπò Í∞ÄÎ°ú */
+        return false;
+    skip[0] = tmp16;
+    if (!hwpf.Read2b(tmp16))                      /* ÏÑ∏Î°ú */
+        return false;
+    skip[1] = tmp16;
+    if (!hwpf.Read2b(tmp16))                      /* ÌôïÎåÄÎπÑÏú® : 0 Í≥†Ï†ï, Ïù¥Ïô∏ ÌçºÏÑºÌä∏ Îã®ÏúÑ Í∞ÄÎ°ú */
+        return false;
+    scale[0] = tmp16;
+    if (!hwpf.Read2b(tmp16))                      /* ÏÑ∏Î°ú */
+        return false;
+    scale[1] = tmp16;
 
     hwpf.Read1b(picinfo.picun.path, 256);         /* ±◊∏≤∆ƒ¿œ ¿Ã∏ß : ¡æ∑˘∞° Drawing¿Ã æ∆¥“∂ß. */
     hwpf.Read1b(reserved3, 9);                    /* π‡±‚/∏Ìæœ/±◊∏≤»ø∞˙ µÓ */
@@ -598,7 +604,10 @@ int Footnote::Read(HWPFile & hwpf)
     hwpf.Read1b(info, 8);
     hwpf.Read2b(&number, 1);
     hwpf.Read2b(&type, 1);
-    width = (short) hwpf.Read2b();
+    unsigned short tmp16;
+    if (!hwpf.Read2b(tmp16))
+        return false;
+    width = tmp16;
     hwpf.ReadParaList(plist, CH_FOOTNOTE);
 
     return !hwpf.State();
-- 
1.9.1

