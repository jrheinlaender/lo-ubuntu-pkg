--- /dev/null	2012-05-23 16:08:20.259348243 +0200
+++ /home/bjoern/checkouts/pkg-libreoffice-3-4/patches/cve-2012-1149-b.diff	2012-05-23 18:09:18.093624326 +0200
@@ -0,0 +1,124 @@
+t format-patch --stdout 9ff94ae0fa947c5fd6a31fbc38421f60eb5e1fba^..9ff94ae0fa947c5fd6a31fbc38421f60eb5e1fba |sed -e 's|^--- a/|--- |' -e 's|^+++ b/|+++ |' > ~/checkouts/pkg-libreoffice-3-4/patches/cve-2012-1149-b.diff
+From 9ff94ae0fa947c5fd6a31fbc38421f60eb5e1fba Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
+Date: Tue, 17 Apr 2012 16:45:23 +0100
+Subject: [PATCH] png parsing regression test
+
+---
+ basebmp/source/bitmapdevice.cxx                    |   12 ++++++--
+# .../qa/cppunit/data/png/fail/CVE-2004-0597-1.png   |    3 ++
+# .../qa/cppunit/data/png/fail/CVE-2005-0633-1.png   |  Bin 0 -> 346 bytes
+# .../qa/cppunit/data/png/fail/CVE-2006-7210-1.png   |  Bin 0 -> 2495 bytes
+# .../qa/cppunit/data/png/fail/CVE-2007-2365-1.png   |  Bin 0 -> 18470 bytes
+# .../qa/cppunit/data/png/fail/CVE-2009-1511-1.png   |    1 +
+# svtools/qa/cppunit/data/png/pass/black.png         |  Bin 0 -> 175 bytes
+# svtools/qa/cppunit/filters-test.cxx                |    4 +++
+ vcl/source/gdi/pngread.cxx                         |   31 ++++++++++++++------
+ 9 files changed, 40 insertions(+), 11 deletions(-)
+ create mode 100644 svtools/qa/cppunit/data/png/fail/.gitignore
+ create mode 100644 svtools/qa/cppunit/data/png/fail/CVE-2004-0597-1.png
+ create mode 100644 svtools/qa/cppunit/data/png/fail/CVE-2005-0633-1.png
+ create mode 100644 svtools/qa/cppunit/data/png/fail/CVE-2006-7210-1.png
+ create mode 100644 svtools/qa/cppunit/data/png/fail/CVE-2007-2365-1.png
+ create mode 100644 svtools/qa/cppunit/data/png/fail/CVE-2009-1511-1.png
+ create mode 100644 svtools/qa/cppunit/data/png/indeterminate/.gitignore
+ create mode 100644 svtools/qa/cppunit/data/png/pass/.gitignore
+ create mode 100644 svtools/qa/cppunit/data/png/pass/black.png
+
+diff --git a/basebmp/source/bitmapdevice.cxx b/basebmp/source/bitmapdevice.cxx
+index 1586fce..b3676c6 100644
+--- basebmp/source/bitmapdevice.cxx
++++ basebmp/source/bitmapdevice.cxx
+@@ -1881,8 +1881,16 @@ BitmapDeviceSharedPtr createBitmapDeviceImpl( const basegfx::B2IVector&
+     // factor in bottom-up scanline order case
+     nScanlineStride *= bTopDown ? 1 : -1;
+ 
+-    const std::size_t nMemSize(
+-        (nScanlineStride < 0 ? -nScanlineStride : nScanlineStride)*rSize.getY() );
++    const sal_uInt32 nWidth(nScanlineStride < 0 ? -nScanlineStride : nScanlineStride);
++    const sal_uInt32 nHeight(rSize.getY());
++
++    if (nHeight && nWidth && nWidth > SAL_MAX_INT32 / nHeight)
++    {
++        //SAL_WARN( "basebmp", "suspicious massive alloc " << nWidth << " * " << nHeight);
++        return BitmapDeviceSharedPtr();
++    }
++
++    const std::size_t nMemSize(nWidth * nHeight);
+ 
+     if( !pMem )
+     {
+diff --git a/vcl/source/gdi/pngread.cxx b/vcl/source/gdi/pngread.cxx
+index a85a8ec..d279c01 100644
+--- vcl/source/gdi/pngread.cxx
++++ vcl/source/gdi/pngread.cxx
+@@ -194,6 +194,7 @@ PNGReaderImpl::PNGReaderImpl( SvStream& rPNGStream )
+     mpScanCurrent   ( NULL ),
+     mpColorTable    ( (sal_uInt8*) mpDefaultColorTable ),
+     mnPass ( 0 ),
++    mbPalette( sal_False ),
+     mbzCodecInUse   ( sal_False ),
+     mbStatus( sal_True),
+     mbIDAT( sal_False ),
+@@ -297,7 +298,7 @@ bool PNGReaderImpl::ReadNextChunk()
+             nCRC32 = rtl_crc32( nCRC32, &rChunkData.aData[ 0 ], mnChunkLen );
+             maDataIter = rChunkData.aData.begin();
+         }
+-        sal_uInt32 nCheck;
++        sal_uInt32 nCheck(0);
+         mrPNGStream >> nCheck;
+         if( nCRC32 != nCheck )
+             return false;
+@@ -339,14 +340,23 @@ BitmapEx PNGReaderImpl::GetBitmapEx( const Size& rPreviewSizeHint )
+     // reset to the first chunk
+     maChunkIter = maChunkSeq.begin();
+ 
+-    // parse the chunks
++    // first chunk must be IDHR
++    if( mbStatus && ReadNextChunk() )
++    {
++        if (mnChunkType == PNGCHUNK_IHDR)
++            mbStatus = ImplReadHeader( rPreviewSizeHint );
++        else
++            mbStatus = false;
++    }
++
++    // parse the remaining chunks
+     while( mbStatus && !mbIDAT && ReadNextChunk() )
+     {
+         switch( mnChunkType )
+         {
+             case PNGCHUNK_IHDR :
+             {
+-                mbStatus = ImplReadHeader( rPreviewSizeHint );
++                mbStatus = false; //IHDR should only appear as the first chunk
+             }
+             break;
+ 
+@@ -756,14 +766,17 @@ sal_Bool PNGReaderImpl::ImplReadTransparent()
+             {
+                 if ( mnChunkLen <= 256 )
+                 {
++                    mbTransparent = true;
+                     mpTransTab = new sal_uInt8 [ 256 ];
+                     rtl_fillMemory( mpTransTab, 256, 0xff );
+-                    rtl_copyMemory( mpTransTab, &(*maDataIter), mnChunkLen );
+-                    maDataIter += mnChunkLen;
+-                    mbTransparent = true;
+-                    // need alpha transparency if not on/off masking
+-                    for( int i = 0; i < mnChunkLen; ++i )
+-                       bNeedAlpha |= (mpTransTab[i]!=0x00) && (mpTransTab[i]!=0xFF);
++                    if (mnChunkLen > 0)
++                    {
++                        rtl_copyMemory( mpTransTab, &(*maDataIter), mnChunkLen );
++                        maDataIter += mnChunkLen;
++                        // need alpha transparency if not on/off masking
++                        for( int i = 0; i < mnChunkLen; ++i )
++                           bNeedAlpha |= (mpTransTab[i]!=0x00) && (mpTransTab[i]!=0xFF);
++                    }
+                 }
+             }
+             break;
+-- 
+1.7.9.5
+
