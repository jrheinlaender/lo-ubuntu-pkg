--- /dev/null	2012-05-27 17:36:15.667085020 +0200
+++ libreoffice-3.4.2/libreoffice-build/patches/hotfixes/cve-2012-2334.diff	2012-05-28 12:48:28.688028781 +0200
@@ -0,0 +1,131 @@
+From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
+diff -ru filter/inc/filter/msfilter/msdffimp.hxx filter/inc/filter/msfilter/msdffimp.hxx
+--- filter/inc/filter/msfilter/msdffimp.hxx	2012-05-17 11:01:06.323446905 +0100
++++ filter/inc/filter/msfilter/msdffimp.hxx	2012-05-17 11:08:23.257229041 +0100
+@@ -77,9 +77,20 @@
+     bool IsContainer() const { return nRecVer == DFF_PSFLAG_CONTAINER; }
+     sal_uLong    GetRecBegFilePos() const { return nFilePos; }
+     sal_uLong    GetRecEndFilePos() const { return nFilePos + DFF_COMMON_RECORD_HEADER_SIZE + nRecLen; }
+-    void SeekToEndOfRecord(SvStream& rIn) const { rIn.Seek(nFilePos + DFF_COMMON_RECORD_HEADER_SIZE + nRecLen ); }
+-    void SeekToContent(    SvStream& rIn) const { rIn.Seek(nFilePos + DFF_COMMON_RECORD_HEADER_SIZE ); }
+-    void SeekToBegOfRecord(SvStream& rIn) const { rIn.Seek( nFilePos ); }
++    bool SeekToEndOfRecord(SvStream& rIn) const
++    {
++        sal_Size nPos = nFilePos + DFF_COMMON_RECORD_HEADER_SIZE + nRecLen;
++        return nPos == rIn.Seek(nPos);
++    }
++    bool SeekToContent(SvStream& rIn) const
++    {
++        sal_Size nPos = nFilePos + DFF_COMMON_RECORD_HEADER_SIZE;
++        return nPos == rIn.Seek(nPos);
++    }
++    bool SeekToBegOfRecord(SvStream& rIn) const
++    {
++        return nFilePos == rIn.Seek(nFilePos);
++    }
+ 
+     MSFILTER_DLLPUBLIC friend SvStream& operator>>(SvStream& rIn, DffRecordHeader& rRec);
+ 
+diff -ru filter/source/msfilter/msdffimp.cxx filter/source/msfilter/msdffimp.cxx
+--- filter/source/msfilter/msdffimp.cxx	2012-05-17 11:01:06.231445683 +0100
++++ filter/source/msfilter/msdffimp.cxx	2012-05-17 11:10:34.159950744 +0100
+@@ -156,6 +156,11 @@
+ static sal_uInt32 nMSOleObjCntr = 0;
+ #define MSO_OLE_Obj "MSO_OLE_Obj"
+ 
++/*************************************************************************/
++bool lclGood(const SvStream &rStream)
++{
++    return rStream.GetError() == 0 && !rStream.IsEof();
++}
+ 
+ /*************************************************************************/
+ BOOL Impl_OlePres::Read( SvStream & rStm )
+@@ -3653,7 +3658,7 @@
+                 rSt >> aEscherF002Hd;
+                 ULONG nEscherF002End = aEscherF002Hd.GetRecEndFilePos();
+                 DffRecordHeader aEscherObjListHd;
+-                while ( rSt.Tell() < nEscherF002End )
++                while (lclGood(rSt) && rSt.Tell() < nEscherF002End)
+                 {
+                     rSt >> aEscherObjListHd;
+                     if ( aEscherObjListHd.nRecVer != 0xf )
+@@ -3687,9 +3692,16 @@
+     FASTBOOL bRet = FALSE;
+     ULONG nFPosMerk = rSt.Tell(); // FilePos merken fuer ggf. spaetere Restauration
+     DffRecordHeader aHd;
++    // make sure that we move somewhere with every iteration
++    sal_Size nStPos;
+     do
+     {
++        nStPos = rSt.Tell();
+         rSt >> aHd;
++        if (!lclGood(rSt))
++            break;
++        if (aHd.nRecLen > nMaxLegalDffRecordLength)
++            break;
+         if ( aHd.nRecType == nRecId )
+         {
+             if ( nSkipCount )
+@@ -3704,9 +3716,13 @@
+             }
+         }
+         if ( !bRet )
+-            aHd.SeekToEndOfRecord( rSt );
++        {
++            bool bSeekSuccess = aHd.SeekToEndOfRecord( rSt );
++            if (!bSeekSuccess)
++                break;
++        }
+     }
+-    while ( rSt.GetError() == 0 && rSt.Tell() < nMaxFilePos && !bRet );
++    while ( lclGood(rSt) && rSt.Tell() < nMaxFilePos && rSt.Tell() != nStPos && !bRet );
+     if ( !bRet )
+         rSt.Seek( nFPosMerk );	// FilePos restaurieren
+     return bRet;
+@@ -6319,10 +6335,17 @@
+ 
+             if ( mnIdClusters-- > 2 )
+             {
+-                if ( aDggAtomHd.nRecLen == ( mnIdClusters * sizeof( FIDCL ) + 16 ) )
++                const sal_Size nFIDCLsize = sizeof(sal_uInt32) * 2;
++                if ( aDggAtomHd.nRecLen == ( mnIdClusters * nFIDCLsize + 16 ) )
+                 {
++                    sal_Size nStCtrlCurr = rStCtrl.Tell();
++                    sal_Size nStCtrlEnd = rStCtrl.Seek(STREAM_SEEK_TO_END);
++                    sal_Size nMaxEntriesPossible = ( nStCtrlEnd - nStCtrlCurr ) / nFIDCLsize;
++                    rStCtrl.Seek(nStCtrlCurr);
++                    mnIdClusters = std::min(nMaxEntriesPossible, static_cast<sal_Size>(mnIdClusters));
+                     mpFidcls = new FIDCL[ mnIdClusters ];
+-                    for ( sal_uInt32 i = 0; i < mnIdClusters; i++ )
++                    memset(mpFidcls, 0, mnIdClusters * sizeof(FIDCL));
++                    for (sal_uInt32 i = 0; i < mnIdClusters; ++i)
+                     {
+                         rStCtrl >> mpFidcls[ i ].dgid
+                                 >> mpFidcls[ i ].cspidCur;
+@@ -7181,7 +7203,11 @@
+     rSt >> nTmp >> rFbt >> rLength;
+     rVer = sal::static_int_cast< BYTE >(nTmp & 15);
+     rInst = nTmp >> 4;
+-    return rSt.GetError() == 0;
++    if (!lclGood(rSt))
++        return false;
++    if (rLength > nMaxLegalDffRecordLength)
++        return false;
++    return true;
+ }
+ 
+ 
+diff -ru svx/inc/svx/msdffdef.hxx svx/inc/svx/msdffdef.hxx
+--- svx/inc/svx/msdffdef.hxx	2012-05-17 11:01:09.195485098 +0100
++++ svx/inc/svx/msdffdef.hxx	2012-05-17 11:10:15.627707282 +0100
+@@ -39,6 +39,9 @@
+ 
+ #define DFF_COMMON_RECORD_HEADER_SIZE			8
+ 
++const sal_uInt32 nMaxLegalDffRecordLength = \
++    SAL_MAX_UINT32 - DFF_COMMON_RECORD_HEADER_SIZE;
++
+ #define DFF_PSFLAG_CONTAINER 0x0F         // If the version field of a record
+                                           //  header takes on this value, the
+                                           //  record header marks the start of
--- libreoffice-3.4.2.orig/libreoffice-build/patches/dev300/apply	2012-05-29 14:35:13.089295688 +0200
+++ libreoffice-3.4.2/libreoffice-build/patches/dev300/apply	2012-05-29 14:35:24.977295849 +0200
@@ -1127,7 +1127,7 @@
 #sw-import-TOC.diff ,n#404254, Amelia Wang
 
 # (disabled) debug code extracting SdrOLE streams to some tmp location
-svx-debug-sdrolestreams.diff, thorsten
+#svx-debug-sdrolestreams.diff, thorsten
 
 [ MinGW ]
 # build fix for odma - not up-stream
