Description: Alpha port
Origin: http://www.openoffice.org/nonav/issues/showattachment.cgi/68357/workspace.linuxaxp01.patch
Bug: http://www.openoffice.org/issues/show_bug.cgi?id=110145
Origin: upstream

diff --git a/patches/dev300/apply b/patches/dev300/apply
index 430f3b0..186cef5 100644
--- openoffice.org-3.2.0/ooo-build-3-2-0-8/patches/dev300/apply
+++ openoffice.org-3.2.0/ooo-build-3-2-0-8/patches/dev300/apply
@@ -35,7 +35,7 @@
 	      KDE4Experimental, MinGW, CalcExperimental, \
 	      OOXMLExportExperimental, CrossWin32Patches, AutoLayout, \
 	      WriterNavigation, WriterDocComparison, SystemGraphiteWithSTLport, \
-	      HPPA, Speed, SystemMySQLWithSTLport
+	      HPPA, AXP, Speed, SystemMySQLWithSTLport
 DebianLooseSections: DebianBaseNoHelpContent
 # Optional sections
 Optional : LiberationFontsOnWindows, NovellOnlyExtensionFixes, Win32OnlyExtensionFixes, Linux32OnlyExtensionFixes
@@ -77,7 +77,7 @@
 Slackware : LinuxCommon, SlackwareOnly, NotDebian, Mono, msaccess, CairoFonts
 # Debian
 DebianBase : LinuxCommon, DebianBaseOnly, GCCSTL, BerkeleyDB43, Split, PostgreSQL, MySQL
-Debian : DebianBase, DebianOnly, DebianSidOnly, Debian32Only, CairoFonts, HPPA
+Debian : DebianBase, DebianOnly, DebianSidOnly, Debian32Only, CairoFonts, HPPA, AXP
 DebianEtch : DebianBase, DebianOnly, DebianEtchOnly, Debian32Only
 # Ubuntu
 UbuntuBased : DebianBase, UbuntuOnly
@@ -3448,6 +3448,9 @@
 [ HPPA < dev300-m66 ]
 cws-linuxhppa1.diff, i#107051
 
+[ AXP ]
+cws-linuxaxp01.diff, i#110145
+
 [ UnstableLibwpd ]
 config_office-testing.diff
 libwpd-testing.diff
--- /dev/null	2010-02-27 12:54:19.449251469 +0100
+++ openoffice.org-3.2.0/ooo-build-3-2-0-8/patches/dev300/cws-linuxaxp01.diff	2010-03-18 17:45:45.000000000 +0100
@@ -0,0 +1,1884 @@
+diff -r f387649cb501 automation/source/testtool/objtest.cxx
+--- automation/source/testtool/objtest.cxx	Fri Mar 12 15:32:45 2010 +0100
++++ automation/source/testtool/objtest.cxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -518,6 +518,8 @@
+     abGP.Append( "21" );  // Linux S390
+ #elif defined LINUX && defined HPPA
+     abGP.Append( "22" );  // Linux PA-RISC
++#elif defined LINUX && defined AXP
++    abGP.Append( "23" );  // Linux ALPHA
+ #else
+ #error ("unknown platform. please request an ID for your platform on qa/dev")
+ #endif
+diff -r f387649cb501 bridges/prj/build.lst
+--- bridges/prj/build.lst	Fri Mar 12 15:32:45 2010 +0100
++++ bridges/prj/build.lst	Mon Mar 15 16:00:09 2010 +0000
+@@ -12,16 +12,17 @@
+ br	bridges\source\cpp_uno\gcc3_freebsd_intel	nmake	-	u	br_gcc3fi br_cppuno_shared br_unotypes br_inc NULL
+ br	bridges\source\cpp_uno\gcc3_linux_x86-64	nmake	-	u	br_gcc3lx br_cppuno_shared br_unotypes br_inc NULL
+ br	bridges\source\cpp_uno\gcc3_freebsd_x86-64	nmake	-	u	br_gcc3fx br_cppuno_shared br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcclp3 br_cppuno_shared br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_powerpc64	nmake	-	u	br_gcclp3_64 br_cppuno_shared br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_mips		nmake	-	u	br_gcc3mips br_cppuno_shared br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_m68k		nmake	-	u	br_gcc3m68k br_cppuno_shared br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gccl33 br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_s390x		nmake	-	u	br_gccl3x br_unotypes br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes br_cppuno_shared br_inc NULL
+-br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gccl3r br_unotypes NULL
+-br	bridges\source\cpp_uno\gcc3_linux_ia64		nmake	-	u	br_gccl3a br_unotypes NULL
+-br	bridges\source\cpp_uno\gcc3_linux_hppa		nmake	-	u	br_gccl3h br_unotypes NULL
++br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcc3lp br_cppuno_shared br_unotypes br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_powerpc64	nmake	-	u	br_gcc3lp_64 br_cppuno_shared br_unotypes br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_mips		nmake	-	u	br_gcc3lmips br_cppuno_shared br_unotypes br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_m68k		nmake	-	u	br_gcc3lm68k br_cppuno_shared br_unotypes br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gcc3l3 br_unotypes br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_s390x		nmake	-	u	br_gcc3l3_64 br_unotypes br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gcc3ls br_unotypes br_cppuno_shared br_inc NULL
++br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gcc3lr br_unotypes NULL
++br	bridges\source\cpp_uno\gcc3_linux_ia64		nmake	-	u	br_gcc3la br_unotypes NULL
++br	bridges\source\cpp_uno\gcc3_linux_hppa		nmake	-	u	br_gcc3lh br_unotypes NULL
++br	bridges\source\cpp_uno\gcc3_linux_alpha		nmake	-	u	br_gcc3ll br_unotypes NULL
+ br	bridges\source\cpp_uno\gcc3_macosx_intel			nmake	-	u	br_gcc3macoxi br_cppuno_shared br_unotypes br_inc NULL
+ br	bridges\source\cpp_uno\gcc3_macosx_powerpc			nmake	-	u	br_gcc3macoxp br_cppuno_shared br_unotypes br_inc NULL
+ br	bridges\source\cpp_uno\cc50_solaris_sparc			nmake	-	u	br_cc50sols br_unotypes br_cppuno_shared br_inc NULL
+diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/cpp2uno.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_alpha/cpp2uno.cxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -0,0 +1,676 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2000, 2010 Oracle and/or its affiliates.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++// MARKER(update_precomp.py): autogen include statement, do not remove
++#include "precompiled_bridges.hxx"
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include <uno/data.h>
++#include <typelib/typedescription.hxx>
++
++#include "bridges/cpp_uno/shared/bridge.hxx"
++#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
++#include "bridges/cpp_uno/shared/types.hxx"
++#include "bridges/cpp_uno/shared/vtablefactory.hxx"
++
++#include "share.hxx"
++#include <stdio.h>
++
++//Calling Standards:
++//  "Calling Standard for Alpha Systems"
++//     (Tru64 UNIX Version 5.1 or higher, August 2000)
++//http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/V51_HTML/ARH9MBTE/TITLE.HTM
++
++using namespace ::com::sun::star::uno;
++
++namespace 
++{
++static typelib_TypeClass cpp2uno_call(
++    bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
++    const typelib_TypeDescription * pMemberTypeDescr,
++    typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
++    sal_Int32 nParams, typelib_MethodParameter * pParams,
++        void ** gpreg, void ** fpreg, void ** ovrflw,
++    sal_Int64 * pRegisterReturn /* space for register return */ )
++{
++#ifdef CMC_DEBUG
++    fprintf(stderr, "as far as cpp2uno_call\n");
++#endif
++    int nregs = 0; //number of words passed in registers
++       
++    // gpreg:  [ret *], this, [gpr params]
++    // fpreg:  [fpr params]
++    // ovrflw: [gpr or fpr params (properly aligned)]
++
++    // return
++    typelib_TypeDescription * pReturnTypeDescr = 0;
++    if (pReturnTypeRef)
++        TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
++    
++    void * pUnoReturn = 0;
++    void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
++    
++    if (pReturnTypeDescr)
++    {
++        if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
++        {
++            pUnoReturn = pRegisterReturn; // direct way for simple types
++        }
++        else // complex return via ptr (pCppReturn)
++        {
++            pCppReturn = *(void **)gpreg;
++            gpreg++;
++            fpreg++;
++            nregs++;
++            
++            pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
++                          ? alloca( pReturnTypeDescr->nSize )
++                          : pCppReturn); // direct way
++        }
++    }
++    // pop this
++    gpreg++; 
++    fpreg++;
++    nregs++;
++
++    // stack space
++    OSL_ENSURE( sizeof(void *) == sizeof(sal_Int64), "### unexpected size!" );
++    // parameters
++    void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
++    void ** pCppArgs = pUnoArgs + nParams;
++    // indizes of values this have to be converted (interface conversion cpp<=>uno)
++    sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
++    // type descriptions for reconversions
++    typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
++    
++    sal_Int32 nTempIndizes   = 0;
++    for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
++    {
++        const typelib_MethodParameter & rParam = pParams[nPos];
++        typelib_TypeDescription * pParamTypeDescr = 0;
++        TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
++
++#ifdef CMC_DEBUG
++        fprintf(stderr, "arg %d of %d\n", nPos, nParams);
++#endif
++
++        if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr )) // value
++        {
++#ifdef CMC_DEBUG
++            fprintf(stderr, "simple type is %d\n", pParamTypeDescr->eTypeClass);
++#endif
++
++            switch (pParamTypeDescr->eTypeClass)
++            {
++                case typelib_TypeClass_FLOAT:
++                case typelib_TypeClass_DOUBLE:
++                    if (nregs < axp::MAX_WORDS_IN_REGS)
++                    {
++                        if (pParamTypeDescr->eTypeClass == typelib_TypeClass_FLOAT)
++                        {
++                            float tmp = (float) (*((double *)fpreg));
++                            (*((float *) fpreg)) = tmp;
++                        }
++
++                        pCppArgs[nPos] = pUnoArgs[nPos] = fpreg;
++                        gpreg++;
++                        fpreg++;
++                        nregs++;
++                    }
++                    else
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                        ovrflw++;
++                    }
++                    break;
++                case typelib_TypeClass_BYTE:
++                case typelib_TypeClass_BOOLEAN:
++                    if (nregs < axp::MAX_WORDS_IN_REGS)
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
++                        gpreg++;
++                        fpreg++;
++                        nregs++;
++                    }
++                    else
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                        ovrflw++;
++                    }
++                    break;
++                case typelib_TypeClass_CHAR:
++                case typelib_TypeClass_SHORT:
++                case typelib_TypeClass_UNSIGNED_SHORT:
++                    if (nregs < axp::MAX_WORDS_IN_REGS)
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
++                        gpreg++;
++                        fpreg++;
++                        nregs++;
++                    }
++                    else
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                        ovrflw++;
++                    }
++                    break;
++                case typelib_TypeClass_ENUM:
++                case typelib_TypeClass_LONG:
++                case typelib_TypeClass_UNSIGNED_LONG:
++                    if (nregs < axp::MAX_WORDS_IN_REGS)
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
++                        gpreg++;
++                        fpreg++;
++                        nregs++;
++                    }
++                    else
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                        ovrflw++;
++                    }
++                    break;
++                default:
++                    if (nregs < axp::MAX_WORDS_IN_REGS)
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
++                        gpreg++;
++                        fpreg++;
++                        nregs++;
++                    }
++                    else
++                    {
++                        pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                        ovrflw++;
++                    }
++                    break;
++            }
++
++            // no longer needed
++            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++        }
++        else // ptr to complex value | ref
++        {
++#ifdef CMC_DEBUG
++            fprintf(stderr, "complex, nregs is %d\n", nregs);
++#endif
++
++            void *pCppStack; //temporary stack pointer
++
++            if (nregs < axp::MAX_WORDS_IN_REGS)
++            { 
++                pCppArgs[nPos] = pCppStack = *gpreg;
++                gpreg++;
++                fpreg++;
++                nregs++;
++            }
++            else
++            {
++                pCppArgs[nPos] = pCppStack = *ovrflw;
++                ovrflw++;
++            }
++
++            if (! rParam.bIn) // is pure out
++            {
++                // uno out is unconstructed mem!
++                pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
++                pTempIndizes[nTempIndizes] = nPos;
++                // will be released at reconversion
++                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++            }
++            // is in/inout
++            else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
++            {
++                uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
++                                        pCppStack, pParamTypeDescr,
++                                        pThis->getBridge()->getCpp2Uno() );
++                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
++                // will be released at reconversion
++                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++            }
++            else // direct way
++            {
++                pUnoArgs[nPos] = pCppStack;
++                // no longer needed
++                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++            }
++        }
++    }
++
++#ifdef CMC_DEBUG
++    fprintf(stderr, "end of params\n");
++#endif
++    
++    // ExceptionHolder
++    uno_Any aUnoExc; // Any will be constructed by callee
++    uno_Any * pUnoExc = &aUnoExc;
++
++    // invoke uno dispatch call
++    (*pThis->getUnoI()->pDispatcher)( pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
++    
++    // in case an exception occured...
++    if (pUnoExc)
++    {
++        // destruct temporary in/inout params
++        for ( ; nTempIndizes--; )
++        {
++            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++            
++            if (pParams[nIndex].bIn) // is in/inout => was constructed
++                uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
++            TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
++        }
++        if (pReturnTypeDescr)
++            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
++        
++        CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, pThis->getBridge()->getUno2Cpp() ); // has to destruct the any
++        // is here for dummy
++        return typelib_TypeClass_VOID;
++    }
++    else // else no exception occured...
++    {
++        // temporary params
++        for ( ; nTempIndizes--; )
++        {
++            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++            typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
++            
++            if (pParams[nIndex].bOut) // inout/out
++            {
++                // convert and assign
++                uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
++                uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
++                                        pThis->getBridge()->getUno2Cpp() );
++            }
++            // destroy temp uno param
++            uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
++            
++            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++        }
++        // return
++        if (pCppReturn) // has complex return
++        {
++            if (pUnoReturn != pCppReturn) // needs reconversion
++            {
++                uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
++                                        pThis->getBridge()->getUno2Cpp() );
++                // destroy temp uno return
++                uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
++            }
++            // complex return ptr is set to return reg
++            *(void **)pRegisterReturn = pCppReturn;
++        }
++        if (pReturnTypeDescr)
++        {
++            typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
++            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
++            return eRet;
++        }
++        else
++            return typelib_TypeClass_VOID;
++    }
++}
++
++
++//============================================================================
++static typelib_TypeClass cpp_mediate(
++    sal_uInt64 nOffsetAndIndex,
++    void ** gpreg, void ** fpreg, void ** ovrflw,
++    sal_Int64 * pRegisterReturn /* space for register return */ )
++{
++    OSL_ENSURE( sizeof(sal_Int64)==sizeof(void *), "### unexpected!" );
++
++    sal_Int32 nVtableOffset = (nOffsetAndIndex >> 32);
++    sal_Int32 nFunctionIndex = (nOffsetAndIndex & 0xFFFFFFFF);
++
++#ifdef CMC_DEBUG
++    fprintf(stderr, "nVTableOffset, nFunctionIndex are %x %x\n", nVtableOffset, nFunctionIndex);
++#endif
++
++#ifdef CMC_DEBUG
++        // Let's figure out what is really going on here
++        {
++            fprintf( stderr, "= cpp_mediate () =\nGPR's (%d): ", 6 );
++            for ( unsigned int i = 0; i < 6; ++i )
++                fprintf( stderr, "0x%lx, ", gpreg[i] );
++            fprintf( stderr, "\n");
++            fprintf( stderr, "\nFPR's (%d): ", 6 );
++            for ( unsigned int i = 0; i < 6; ++i )
++                fprintf( stderr, "0x%lx (%f), ", fpreg[i], fpreg[i] );
++            fprintf( stderr, "\n");
++        }
++#endif
++
++    
++    // gpreg:  [ret *], this, [other gpr params]
++    // fpreg:  [fpr params]
++    // ovrflw: [gpr or fpr params (properly aligned)]
++
++    // _this_ ptr is patched cppu_XInterfaceProxy object
++    void * pThis;
++    if( nFunctionIndex & 0x80000000 )
++    {
++        nFunctionIndex &= 0x7fffffff;
++        pThis = gpreg[1];
++    }
++    else
++    {
++        pThis = gpreg[0];
++    }
++
++    pThis = static_cast< char * >(pThis) - nVtableOffset;
++    
++    bridges::cpp_uno::shared::CppInterfaceProxy * pCppI
++        = bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy(
++            pThis);
++
++    typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
++
++    
++    OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
++    if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
++    {
++        throw RuntimeException(
++            rtl::OUString::createFromAscii("illegal vtable index!"),
++            (XInterface *)pCppI );
++    }
++    
++    // determine called method
++    OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
++    sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
++    OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
++
++    TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
++    
++    typelib_TypeClass eRet;
++    switch (aMemberDescr.get()->eTypeClass)
++    {
++    case typelib_TypeClass_INTERFACE_ATTRIBUTE:
++    {
++        if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
++        {
++            // is GET method
++            eRet = cpp2uno_call(
++                pCppI, aMemberDescr.get(),
++                ((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
++                0, 0, // no params
++                gpreg, fpreg, ovrflw, pRegisterReturn );
++        }
++        else
++        {
++            // is SET method
++            typelib_MethodParameter aParam;
++            aParam.pTypeRef =
++                ((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
++            aParam.bIn      = sal_True;
++            aParam.bOut     = sal_False;
++            
++            eRet = cpp2uno_call(
++                pCppI, aMemberDescr.get(),
++                0, // indicates void return
++                1, &aParam,
++                gpreg, fpreg, ovrflw, pRegisterReturn );
++        }
++        break;
++    }
++    case typelib_TypeClass_INTERFACE_METHOD:
++    {
++        // is METHOD
++        switch (nFunctionIndex)
++        {
++        case 1: // acquire()
++            pCppI->acquireProxy(); // non virtual call!
++            eRet = typelib_TypeClass_VOID;
++            break;
++        case 2: // release()
++            pCppI->releaseProxy(); // non virtual call!
++            eRet = typelib_TypeClass_VOID;
++            break;
++        case 0: // queryInterface() opt
++        {
++            typelib_TypeDescription * pTD = 0;
++            TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
++            if (pTD)
++            {
++                XInterface * pInterface = 0;
++                (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
++                    pCppI->getBridge()->getCppEnv(),
++                    (void **)&pInterface, pCppI->getOid().pData, 
++                    (typelib_InterfaceTypeDescription *)pTD );
++            
++                if (pInterface)
++                {
++                    ::uno_any_construct(
++                        reinterpret_cast< uno_Any * >( gpreg[0] ),
++                        &pInterface, pTD, cpp_acquire );
++                    pInterface->release();
++                    TYPELIB_DANGER_RELEASE( pTD );
++                    *(void **)pRegisterReturn = gpreg[0];
++                    eRet = typelib_TypeClass_ANY;
++                    break;
++                }
++                TYPELIB_DANGER_RELEASE( pTD );
++            }
++        } // else perform queryInterface()
++        default:
++            eRet = cpp2uno_call(
++                pCppI, aMemberDescr.get(),
++                ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
++                ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
++                ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
++                gpreg, fpreg, ovrflw, pRegisterReturn );
++        }
++        break;
++    }
++    default:
++    {
++        throw RuntimeException(
++            rtl::OUString::createFromAscii("no member description found!"),
++            (XInterface *)pCppI );
++        // is here for dummy
++        eRet = typelib_TypeClass_VOID;
++    }
++    }
++
++    return eRet;
++}
++
++long cpp_vtable_call(long r16, long r17, long r18, long r19, long r20, long r21, long firstonstack)
++{
++    register long r1 asm("$1");
++    sal_uInt64 nOffsetAndIndex = r1;
++
++    long sp = (long)&firstonstack;
++
++    sal_uInt64 gpreg[axp::MAX_GPR_REGS];
++    gpreg[0] = r16;
++    gpreg[1] = r17;
++    gpreg[2] = r18;
++    gpreg[3] = r19;
++    gpreg[4] = r20;
++    gpreg[5] = r21;
++
++    double fpreg[axp::MAX_SSE_REGS];
++    register double f16  asm("$f16");  fpreg[0] = f16;
++    register double f17  asm("$f17");  fpreg[1] = f17;
++    register double f18  asm("$f18");  fpreg[2] = f18;
++    register double f19  asm("$f19");  fpreg[3] = f19;
++    register double f20  asm("$f20");  fpreg[4] = f20;
++    register double f21  asm("$f21");  fpreg[5] = f21;
++
++    volatile long nRegReturn[1];
++#ifdef CMC_DEBUG
++    fprintf(stderr, "before mediate with %lx\n",nOffsetAndIndex);
++    fprintf(stderr, "non-doubles are %x %x %x %x %x %x\n", gpreg[0], gpreg[1], gpreg[2], gpreg[3], gpreg[4], gpreg[5]);
++    fprintf(stderr, "doubles are %f %f %f %f %f %f\n", fpreg[0], fpreg[1], fpreg[2], fpreg[3], fpreg[4], fpreg[5]);
++#endif
++    typelib_TypeClass aType = 
++        cpp_mediate( nOffsetAndIndex, (void**)gpreg, (void**)fpreg, (void**)sp, 
++            (sal_Int64*)nRegReturn );
++#ifdef CMC_DEBUG
++    fprintf(stderr, "after mediate ret is %lx %ld\n", nRegReturn[0], nRegReturn[0]);
++#endif
++
++    switch( aType )
++    {
++        case typelib_TypeClass_BOOLEAN:
++        case typelib_TypeClass_BYTE:
++            nRegReturn[0] = (unsigned long)(*(unsigned char *)nRegReturn);
++            break;
++        case typelib_TypeClass_CHAR:
++        case typelib_TypeClass_UNSIGNED_SHORT:
++        case typelib_TypeClass_SHORT:
++            nRegReturn[0] = (unsigned long)(*(unsigned short *)nRegReturn);
++            break;
++        case typelib_TypeClass_ENUM:
++        case typelib_TypeClass_UNSIGNED_LONG:
++        case typelib_TypeClass_LONG:
++            nRegReturn[0] = (unsigned long)(*(unsigned int *)nRegReturn);
++            break;
++        case typelib_TypeClass_VOID:
++        default:
++            break;
++        case typelib_TypeClass_FLOAT:
++            {
++                double tmp = (double) (*((float *)nRegReturn));
++                (*((double *) nRegReturn)) = tmp;
++            }
++            //deliberate fall through
++        case typelib_TypeClass_DOUBLE:
++            __asm__ ( "ldt $f0,%0\n\t"
++                : : "m" (*((double*)nRegReturn)) : "$f0");
++            break;
++    }
++    return nRegReturn[0];
++}
++
++const int codeSnippetSize = 32;
++
++unsigned char *codeSnippet( unsigned char * code, sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset, bool simple_ret_type )
++{
++    if (! simple_ret_type)
++        nFunctionIndex |= 0x80000000;
++
++    unsigned char * p = code;
++    *(unsigned int*)&p[0]  = 0x47fb0401;        /* mov $27,$1           */
++    *(unsigned int*)&p[4]  = 0xa43b0010;        /* ldq $1,16($27)      */
++    *(unsigned int*)&p[8]  = 0xa77b0018;        /* ldq $27,24($27)      */
++    *(unsigned int*)&p[12] = 0x6bfb0000;        /* jmp $31,($27),0      */
++    *(unsigned int*)&p[16] = nFunctionIndex;
++    *(unsigned int*)&p[20] = nVtableOffset;
++    *(unsigned long*)&p[24] = (unsigned long)cpp_vtable_call;
++    return (code + codeSnippetSize);
++}
++}
++
++void bridges::cpp_uno::shared::VtableFactory::flushCode(unsigned char const *, unsigned char const *)
++{
++    //http://www.gnu.org/software/lightning/manual/html_node/Standard-functions.html
++    __asm__ __volatile__("call_pal 0x86");
++}
++
++struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
++
++bridges::cpp_uno::shared::VtableFactory::Slot *
++bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
++{
++    return static_cast< Slot * >(block) + 2;
++}
++
++sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
++    sal_Int32 slotCount)
++{
++    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
++}
++
++bridges::cpp_uno::shared::VtableFactory::Slot *
++bridges::cpp_uno::shared::VtableFactory::initializeBlock(
++    void * block, sal_Int32 slotCount)
++{
++    Slot * slots = mapBlockToVtable(block);
++    slots[-2].fn = 0;
++    slots[-1].fn = 0;
++    return slots + slotCount;
++}
++
++unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
++    Slot ** slots, unsigned char * code, sal_PtrDiff writetoexecdiff,
++    typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
++    sal_Int32 functionCount, sal_Int32 vtableOffset)
++{
++    (*slots) -= functionCount;
++    Slot * s = *slots;
++#ifdef CMC_DEBUG
++    fprintf(stderr, "in addLocalFunctions functionOffset is %x\n",functionOffset);
++    fprintf(stderr, "in addLocalFunctions vtableOffset is %x\n",vtableOffset);
++#endif
++
++    for (sal_Int32 i = 0; i < type->nMembers; ++i) {
++        typelib_TypeDescription * member = 0;
++        TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
++        OSL_ASSERT(member != 0);
++        switch (member->eTypeClass) {
++        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
++            // Getter:
++            (s++)->fn = code + writetoexecdiff;
++            code = codeSnippet(
++                code, functionOffset++, vtableOffset,
++                bridges::cpp_uno::shared::isSimpleType(
++                    reinterpret_cast<
++                    typelib_InterfaceAttributeTypeDescription * >(
++                        member)->pAttributeTypeRef));
++
++            // Setter:
++            if (!reinterpret_cast<
++                typelib_InterfaceAttributeTypeDescription * >(
++                    member)->bReadOnly)
++            {
++                (s++)->fn = code + writetoexecdiff;
++                code = codeSnippet(code, functionOffset++, vtableOffset, true);
++            }
++            break;
++
++        case typelib_TypeClass_INTERFACE_METHOD:
++            (s++)->fn = code + writetoexecdiff;
++            code = codeSnippet(
++                code, functionOffset++, vtableOffset,
++                bridges::cpp_uno::shared::isSimpleType(
++                    reinterpret_cast<
++                    typelib_InterfaceMethodTypeDescription * >(
++                        member)->pReturnTypeRef));
++            break;
++
++        default:
++            OSL_ASSERT(false);
++            break;
++        }
++        TYPELIB_DANGER_RELEASE(member);
++    }
++    return code;
++}
++
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/except.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_alpha/except.cxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -0,0 +1,287 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2000, 2010 Oracle and/or its affiliates.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++// MARKER(update_precomp.py): autogen include statement, do not remove
++#include "precompiled_bridges.hxx"
++
++#include <stdio.h>
++#include <string.h>
++#include <dlfcn.h>
++#include <cxxabi.h>
++#include <hash_map>
++
++#include <rtl/strbuf.hxx>
++#include <rtl/ustrbuf.hxx>
++#include <osl/diagnose.h>
++#include <osl/mutex.hxx>
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include <typelib/typedescription.hxx>
++#include <uno/any2.h>
++
++#include "share.hxx"
++
++
++using namespace ::std;
++using namespace ::osl;
++using namespace ::rtl;
++using namespace ::com::sun::star::uno;
++using namespace ::__cxxabiv1;
++
++
++namespace CPPU_CURRENT_NAMESPACE
++{
++
++void dummy_can_throw_anything( char const * )
++{
++}
++
++//==================================================================================================
++static OUString toUNOname( char const * p ) SAL_THROW( () )
++{
++#if OSL_DEBUG_LEVEL > 1
++    char const * start = p;
++#endif
++
++    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
++
++    OUStringBuffer buf( 64 );
++    OSL_ASSERT( 'N' == *p );
++    ++p; // skip N
++
++    while ('E' != *p)
++    {
++        // read chars count
++        long n = (*p++ - '0');
++        while ('0' <= *p && '9' >= *p)
++        {
++            n *= 10;
++            n += (*p++ - '0');
++        }
++        buf.appendAscii( p, n );
++        p += n;
++        if ('E' != *p)
++            buf.append( (sal_Unicode)'.' );
++    }
++
++#if OSL_DEBUG_LEVEL > 1
++    OUString ret( buf.makeStringAndClear() );
++    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
++    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
++    return ret;
++#else
++    return buf.makeStringAndClear();
++#endif
++}
++
++//==================================================================================================
++class RTTI
++{
++    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
++
++    Mutex m_mutex;
++    t_rtti_map m_rttis;
++    t_rtti_map m_generatedRttis;
++
++    void * m_hApp;
++
++public:
++    RTTI() SAL_THROW( () );
++    ~RTTI() SAL_THROW( () );
++
++    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
++};
++//__________________________________________________________________________________________________
++RTTI::RTTI() SAL_THROW( () )
++    : m_hApp( dlopen( 0, RTLD_LAZY ) )
++{
++}
++//__________________________________________________________________________________________________
++RTTI::~RTTI() SAL_THROW( () )
++{
++    dlclose( m_hApp );
++}
++
++//__________________________________________________________________________________________________
++type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
++{
++    type_info * rtti;
++
++    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
++
++    MutexGuard guard( m_mutex );
++    t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
++    if (iRttiFind == m_rttis.end())
++    {
++        // RTTI symbol
++        OStringBuffer buf( 64 );
++        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
++        sal_Int32 index = 0;
++        do
++        {
++            OUString token( unoName.getToken( 0, '.', index ) );
++            buf.append( token.getLength() );
++            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
++            buf.append( c_token );
++        }
++        while (index >= 0);
++        buf.append( 'E' );
++
++        OString symName( buf.makeStringAndClear() );
++        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
++
++        if (rtti)
++        {
++            pair< t_rtti_map::iterator, bool > insertion(
++                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
++            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
++        }
++        else
++        {
++            // try to lookup the symbol in the generated rtti map
++            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
++            if (iFind == m_generatedRttis.end())
++            {
++                // we must generate it !
++                // symbol and rtti-name is nearly identical,
++                // the symbol is prefixed with _ZTI
++                char const * rttiName = symName.getStr() +4;
++#if OSL_DEBUG_LEVEL > 1
++                fprintf( stderr,"generated rtti for %s\n", rttiName );
++#endif
++                if (pTypeDescr->pBaseTypeDescription)
++                {
++                    // ensure availability of base
++                    type_info * base_rtti = getRTTI(
++                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
++                    rtti = new __si_class_type_info(
++                        strdup( rttiName ), (__class_type_info *)base_rtti );
++                }
++                else
++                {
++                    // this class has no base class
++                    rtti = new __class_type_info( strdup( rttiName ) );
++                }
++
++                pair< t_rtti_map::iterator, bool > insertion(
++                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
++                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
++            }
++            else // taking already generated rtti
++            {
++                rtti = iFind->second;
++            }
++        }
++    }
++    else
++    {
++        rtti = iRttiFind->second;
++    }
++
++    return rtti;
++}
++
++//--------------------------------------------------------------------------------------------------
++static void deleteException( void * pExc )
++{
++    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
++    typelib_TypeDescription * pTD = 0;
++    OUString unoName( toUNOname( header->exceptionType->name() ) );
++    ::typelib_typedescription_getByName( &pTD, unoName.pData );
++    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
++    if (pTD)
++    {
++        ::uno_destructData( pExc, pTD, cpp_release );
++        ::typelib_typedescription_release( pTD );
++    }
++}
++
++//==================================================================================================
++void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
++{
++    void * pCppExc;
++    type_info * rtti;
++
++    {
++    // construct cpp exception object
++    typelib_TypeDescription * pTypeDescr = 0;
++    TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
++    OSL_ASSERT( pTypeDescr );
++    if (! pTypeDescr)
++        terminate();
++
++    pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
++    ::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
++
++    // destruct uno exception
++    ::uno_any_destruct( pUnoExc, 0 );
++    // avoiding locked counts
++    static RTTI * s_rtti = 0;
++    if (! s_rtti)
++    {
++        MutexGuard guard( Mutex::getGlobalMutex() );
++        if (! s_rtti)
++        {
++#ifdef LEAK_STATIC_DATA
++            s_rtti = new RTTI();
++#else
++            static RTTI rtti_data;
++            s_rtti = &rtti_data;
++#endif
++        }
++    }
++    rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
++    TYPELIB_DANGER_RELEASE( pTypeDescr );
++    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
++    if (! rtti)
++        terminate();
++    }
++
++    __cxa_throw( pCppExc, rtti, deleteException );
++}
++
++//==================================================================================================
++void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
++{
++    OSL_ENSURE( header, "### no exception header!!!" );
++    if (! header)
++        terminate();
++
++    typelib_TypeDescription * pExcTypeDescr = 0;
++    OUString unoName( toUNOname( header->exceptionType->name() ) );
++    ::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
++    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
++    if (! pExcTypeDescr)
++        terminate();
++
++    // construct uno exception any
++    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
++    ::typelib_typedescription_release( pExcTypeDescr );
++}
++
++}
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/makefile.mk
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_alpha/makefile.mk	Mon Mar 15 16:00:09 2010 +0000
+@@ -0,0 +1,77 @@
++#*************************************************************************
++#
++# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++# 
++# Copyright 2000, 2010 Oracle and/or its affiliates.
++#
++# OpenOffice.org - a multi-platform office productivity suite
++#
++# This file is part of OpenOffice.org.
++#
++# OpenOffice.org is free software: you can redistribute it and/or modify
++# it under the terms of the GNU Lesser General Public License version 3
++# only, as published by the Free Software Foundation.
++#
++# OpenOffice.org is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU Lesser General Public License version 3 for more details
++# (a copy is included in the LICENSE file that accompanied this code).
++#
++# You should have received a copy of the GNU Lesser General Public License
++# version 3 along with OpenOffice.org.  If not, see
++# <http://www.openoffice.org/license.html>
++# for a copy of the LGPLv3 License.
++#
++#*************************************************************************
++
++PRJ=..$/..$/..
++
++PRJNAME=bridges
++TARGET=gcc3_uno
++LIBTARGET=no
++ENABLE_EXCEPTIONS=TRUE
++
++# --- Settings -----------------------------------------------------
++
++.INCLUDE :  settings.mk
++
++# --- Files --------------------------------------------------------
++
++.IF "$(COM)$(OS)$(CPU)" == "GCCLINUXL"
++
++.IF "$(cppu_no_leak)" == ""
++CFLAGS += -DLEAK_STATIC_DATA
++.ENDIF
++
++# In case someone enabled the non-standard -fomit-frame-pointer which does not
++# work with the .cxx sources in this directory:
++CFLAGSCXX += -fno-omit-frame-pointer
++
++CFLAGSNOOPT=-O0
++
++SLOFILES= \
++	$(SLO)$/except.obj		\
++	$(SLO)$/cpp2uno.obj		\
++	$(SLO)$/uno2cpp.obj
++
++SHL1TARGET= $(TARGET)
++
++SHL1DEF=$(MISC)$/$(SHL1TARGET).def
++SHL1IMPLIB=i$(TARGET)
++SHL1VERSIONMAP=..$/..$/bridge_exports.map
++SHL1RPATH=URELIB
++
++SHL1OBJS = $(SLOFILES)
++SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
++
++SHL1STDLIBS= \
++        $(CPPULIB)                      \
++        $(SALLIB)
++
++.ENDIF
++
++# --- Targets ------------------------------------------------------
++
++.INCLUDE :  target.mk
++
+diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/share.hxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_alpha/share.hxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -0,0 +1,98 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2000, 2010 Oracle and/or its affiliates.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++#include "uno/mapping.h"
++
++#include <typeinfo>
++#include <exception>
++#include <cstddef>
++
++namespace CPPU_CURRENT_NAMESPACE
++{
++
++  void dummy_can_throw_anything( char const * );
++
++
++// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
++
++struct _Unwind_Exception
++{
++    unsigned exception_class __attribute__((__mode__(__DI__)));
++    void * exception_cleanup;
++    unsigned private_1 __attribute__((__mode__(__word__)));
++    unsigned private_2 __attribute__((__mode__(__word__)));
++} __attribute__((__aligned__));
++
++struct __cxa_exception
++{ 
++    ::std::type_info *exceptionType;
++    void (*exceptionDestructor)(void *); 
++    
++    ::std::unexpected_handler unexpectedHandler;
++    ::std::terminate_handler terminateHandler;
++    
++    __cxa_exception *nextException;
++    
++    int handlerCount;
++    
++    int handlerSwitchValue;
++    const unsigned char *actionRecord;
++    const unsigned char *languageSpecificData;
++    void *catchTemp;
++    void *adjustedPtr;
++    
++    _Unwind_Exception unwindHeader;
++};    
++
++extern "C" void *__cxa_allocate_exception(
++    std::size_t thrown_size ) throw();
++extern "C" void __cxa_throw (
++    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
++
++struct __cxa_eh_globals
++{
++    __cxa_exception *caughtExceptions;
++    unsigned int uncaughtExceptions;
++};
++extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
++
++// -----
++
++//==================================================================================================
++void raiseException(
++    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
++//==================================================================================================
++void fillUnoException(
++    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
++}
++
++namespace axp
++{
++    enum axplimits { MAX_WORDS_IN_REGS = 6, MAX_GPR_REGS = 6, MAX_SSE_REGS = 6 };
++}
++
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r f387649cb501 bridges/source/cpp_uno/gcc3_linux_alpha/uno2cpp.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_alpha/uno2cpp.cxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -0,0 +1,532 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2000, 2010 Oracle and/or its affiliates.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++// MARKER(update_precomp.py): autogen include statement, do not remove
++#include "precompiled_bridges.hxx"
++
++#include <malloc.h>
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include <uno/data.h>
++
++#include "bridges/cpp_uno/shared/bridge.hxx"
++#include "bridges/cpp_uno/shared/types.hxx"
++#include "bridges/cpp_uno/shared/unointerfaceproxy.hxx"
++#include "bridges/cpp_uno/shared/vtables.hxx"
++
++#include "share.hxx"
++
++#include <stdio.h>
++#include <string.h>
++
++
++using namespace ::rtl;
++using namespace ::com::sun::star::uno;
++
++void MapReturn(long r0, typelib_TypeClass eTypeClass, sal_uInt64* pRegisterReturn)
++{
++    register float fret asm("$f0");
++    register double dret asm("$f0");
++
++#ifdef CMC_DEBUG
++    fprintf(stderr,"Mapping Return with %lx %ld %f\n", r0, r0, dret);
++#endif
++    switch (eTypeClass)
++    {
++    case typelib_TypeClass_HYPER:
++    case typelib_TypeClass_UNSIGNED_HYPER:
++            *pRegisterReturn = r0;
++            break;
++    case typelib_TypeClass_LONG:
++    case typelib_TypeClass_UNSIGNED_LONG:
++    case typelib_TypeClass_ENUM:
++            *(unsigned int*)pRegisterReturn = (unsigned int)r0;
++            break;
++    case typelib_TypeClass_CHAR:
++    case typelib_TypeClass_SHORT:
++    case typelib_TypeClass_UNSIGNED_SHORT:
++            *(unsigned short*)pRegisterReturn = (unsigned short)r0;
++            break;
++    case typelib_TypeClass_BOOLEAN:
++    case typelib_TypeClass_BYTE:
++            *(unsigned char*)pRegisterReturn = (unsigned char)r0;
++            break;
++    case typelib_TypeClass_FLOAT:
++            *reinterpret_cast<float *>( pRegisterReturn ) = fret;
++            break;
++    case typelib_TypeClass_DOUBLE:
++            *reinterpret_cast<double *>( pRegisterReturn ) = dret;
++            break;
++    default:
++            break;
++    }
++#ifdef CMC_DEBUG
++    fprintf(stderr, "end of MapReturn with %x\n", pRegisterReturn ? *pRegisterReturn : 0);
++#endif
++}
++
++#define INSERT_FLOAT( pSV, nr, pFPR, pDS ) \
++    { \
++        if ( nr < axp::MAX_WORDS_IN_REGS ) \
++        { \
++                pFPR[nr++] = *reinterpret_cast<float *>( pSV ); \
++        } \
++        else \
++                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); \
++    }
++
++#define INSERT_DOUBLE( pSV, nr, pFPR, pDS ) \
++        if ( nr < axp::MAX_WORDS_IN_REGS ) \
++                pFPR[nr++] = *reinterpret_cast<double *>( pSV ); \
++        else \
++                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV ); // verbatim!
++
++#define INSERT_INT64( pSV, nr, pGPR, pDS ) \
++        if ( nr < axp::MAX_WORDS_IN_REGS ) \
++                pGPR[nr++] = *reinterpret_cast<sal_uInt64 *>( pSV ); \
++        else \
++                *pDS++ = *reinterpret_cast<sal_uInt64 *>( pSV );
++
++#define INSERT_INT32( pSV, nr, pGPR, pDS ) \
++        if ( nr < axp::MAX_WORDS_IN_REGS ) \
++                pGPR[nr++] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
++        else \
++                *pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV );
++
++#define INSERT_INT16( pSV, nr, pGPR, pDS ) \
++        if ( nr < axp::MAX_WORDS_IN_REGS ) \
++                pGPR[nr++] = *reinterpret_cast<sal_uInt16 *>( pSV ); \
++        else \
++                *pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV );
++
++#define INSERT_INT8( pSV, nr, pGPR, pDS ) \
++        if ( nr < axp::MAX_WORDS_IN_REGS ) \
++                pGPR[nr++] = *reinterpret_cast<sal_uInt8 *>( pSV ); \
++        else \
++                *pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV );
++
++namespace
++{
++//==================================================================================================
++void callVirtualMethod(
++    void * pThis, sal_Int32 nVtableIndex,
++    void * pRegisterReturn, typelib_TypeDescription * pReturnTypeDescr,
++    sal_uInt64 *pStack, sal_uInt32 nStack,
++    sal_uInt64 *pGPR, sal_uInt32 nGPR,
++    double *pFPR, sal_uInt32 nFPR)
++{
++    // Should not happen, but...
++    if ( nFPR > axp::MAX_SSE_REGS )
++        nFPR = axp::MAX_SSE_REGS;
++    if ( nGPR > axp::MAX_GPR_REGS )
++        nGPR = axp::MAX_GPR_REGS;
++
++#ifdef CMC_DEBUG
++        // Let's figure out what is really going on here
++        {
++            fprintf( stderr, "= nStack is %d\n", nStack );
++            fprintf( stderr, "= callVirtualMethod() =\nGPR's (%d): ", nGPR );
++            for ( unsigned int i = 0; i < nGPR; ++i )
++                fprintf( stderr, "0x%lx, ", pGPR[i] );
++            fprintf( stderr, "\nFPR's (%d): ", nFPR );
++            for ( unsigned int i = 0; i < nFPR; ++i )
++                fprintf( stderr, "0x%lx (%f), ", pFPR[i], pFPR[i] );
++            fprintf( stderr, "\nStack (%d): ", nStack );
++            for ( unsigned int i = 0; i < nStack; ++i )
++                fprintf( stderr, "0x%lx, ", pStack[i] );
++            fprintf( stderr, "\n" );
++            fprintf( stderr, "pRegisterReturn is %p\n", pRegisterReturn);
++        }
++#endif
++
++    // Load parameters to stack, if necessary
++    // Stack, if used, must be 8-bytes aligned
++    sal_uInt64 *stack = (sal_uInt64 *) __builtin_alloca( nStack * 8 );
++    memcpy( stack, pStack, nStack * 8 );
++
++    // To get pointer to method
++    // a) get the address of the vtable
++    sal_uInt64 pMethod = *((sal_uInt64 *)pThis);
++    // b) get the address from the vtable entry at offset
++    pMethod += 8 * nVtableIndex;
++    pMethod = *((sal_uInt64 *)pMethod);
++
++    typedef void (* FunctionCall )( sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64, sal_uInt64 );
++    FunctionCall pFunc = (FunctionCall)pMethod;
++
++    switch (nFPR) //deliberate fall through
++    {
++        case 6:
++            asm volatile("ldt $f16,%0" :: "m"(pFPR[5]) : "$f16");
++        case 5:
++            asm volatile("ldt $f17,%0" :: "m"(pFPR[4]) : "$f17");
++        case 4:
++            asm volatile("ldt $f18,%0" :: "m"(pFPR[3]) : "$f18");
++        case 3:
++            asm volatile("ldt $f19,%0" :: "m"(pFPR[2]) : "$f19");
++        case 2:
++            asm volatile("ldt $f20,%0" :: "m"(pFPR[1]) : "$f20");
++        case 1:
++            asm volatile("ldt $f21,%0" :: "m"(pFPR[0]) : "$f21");
++        default:
++            break;
++    }
++
++    (*pFunc)(pGPR[0], pGPR[1], pGPR[2], pGPR[3], pGPR[4], pGPR[5]);
++    register sal_uInt64 r0 __asm__("$0");
++    MapReturn(r0, pReturnTypeDescr->eTypeClass, (sal_uInt64*)pRegisterReturn);
++}
++
++
++//============================================================================ 
++static void cpp_call(
++        bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
++        bridges::cpp_uno::shared::VtableSlot  aVtableSlot,
++        typelib_TypeDescriptionReference * pReturnTypeRef,
++    sal_Int32 nParams, typelib_MethodParameter * pParams,
++    void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
++{
++    // max space for: [complex ret ptr], values|ptr ...
++    sal_uInt64 * pStack = (sal_uInt64 *)alloca( (nParams+3) * sizeof(sal_Int64) );
++    sal_uInt64 * pStackStart = pStack;
++
++    sal_uInt64 pGPR[axp::MAX_GPR_REGS];
++    double pFPR[axp::MAX_SSE_REGS];
++    sal_uInt32 nRegs = 0;
++    
++    // return
++    typelib_TypeDescription * pReturnTypeDescr = 0;
++    TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
++    OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
++    
++    void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
++
++    if (pReturnTypeDescr)
++    {
++        if (bridges::cpp_uno::shared::isSimpleType( pReturnTypeDescr ))
++        {
++            pCppReturn = pUnoReturn; // direct way for simple types
++        }
++        else
++        {
++            // complex return via ptr
++            pCppReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
++                                                ? alloca( pReturnTypeDescr->nSize )
++                                                : pUnoReturn); // direct way
++            INSERT_INT64( &pCppReturn, nRegs, pGPR, pStack );
++        }
++    }
++        // push "this" pointer
++    void * pAdjustedThisPtr = reinterpret_cast< void ** >( pThis->getCppI() ) + aVtableSlot.offset;
++
++    INSERT_INT64( &pAdjustedThisPtr, nRegs, pGPR, pStack );
++
++    // stack space
++    OSL_ENSURE( sizeof(void *) == sizeof(sal_Int64), "### unexpected size!" );
++    // args
++    void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
++    // indizes of values this have to be converted (interface conversion cpp<=>uno)
++    sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
++    // type descriptions for reconversions
++    typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
++    
++    sal_Int32 nTempIndizes   = 0;
++    
++    for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
++    {
++        const typelib_MethodParameter & rParam = pParams[nPos];
++        typelib_TypeDescription * pParamTypeDescr = 0;
++        TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
++        
++        if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
++        {
++            uno_copyAndConvertData( pCppArgs[nPos] = alloca( 8 ), pUnoArgs[nPos], pParamTypeDescr,
++                                    pThis->getBridge()->getUno2Cpp() );
++
++            switch (pParamTypeDescr->eTypeClass)
++            {
++                case typelib_TypeClass_HYPER:
++                case typelib_TypeClass_UNSIGNED_HYPER:
++                    INSERT_INT64( pCppArgs[nPos], nRegs, pGPR, pStack );
++                    break;
++                case typelib_TypeClass_LONG:
++                case typelib_TypeClass_UNSIGNED_LONG:
++                case typelib_TypeClass_ENUM:
++                    INSERT_INT32( pCppArgs[nPos], nRegs, pGPR, pStack );
++                    break;
++                case typelib_TypeClass_SHORT:
++                case typelib_TypeClass_CHAR:
++                case typelib_TypeClass_UNSIGNED_SHORT:
++                    INSERT_INT16( pCppArgs[nPos], nRegs, pGPR, pStack );
++                    break;
++                case typelib_TypeClass_BOOLEAN:
++                case typelib_TypeClass_BYTE:
++                    INSERT_INT8( pCppArgs[nPos], nRegs, pGPR, pStack );
++                    break;
++                case typelib_TypeClass_FLOAT:
++                    INSERT_FLOAT( pCppArgs[nPos], nRegs, pFPR, pStack );
++                    break;
++                case typelib_TypeClass_DOUBLE:
++                    INSERT_DOUBLE( pCppArgs[nPos], nRegs, pFPR, pStack );
++                    break;
++                default:
++                    break;
++            }
++
++            // no longer needed
++            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++        }
++        else // ptr to complex value | ref
++        {
++            if (! rParam.bIn) // is pure out
++            {
++                // cpp out is constructed mem, uno out is not!
++                uno_constructData(
++                    pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
++                    pParamTypeDescr );
++                pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
++                // will be released at reconversion
++                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++            }
++            // is in/inout
++            else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
++            {
++                uno_copyAndConvertData(
++                    pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
++                    pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
++                
++                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
++                // will be released at reconversion
++                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++            }
++            else // direct way
++            {
++                pCppArgs[nPos] = pUnoArgs[nPos];
++                // no longer needed
++                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++            }
++            INSERT_INT64( &(pCppArgs[nPos]), nRegs, pGPR, pStack );
++        }
++    }
++  
++    try
++    {
++        callVirtualMethod(
++            pAdjustedThisPtr, aVtableSlot.index,
++            pCppReturn, pReturnTypeDescr,
++            pStackStart, (pStack - pStackStart),
++            pGPR, nRegs,
++            pFPR, nRegs );
++        // NO exception occured...
++        *ppUnoExc = 0;
++        
++        // reconvert temporary params
++        for ( ; nTempIndizes--; )
++        {
++            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++            typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
++            
++            if (pParams[nIndex].bIn)
++            {
++                if (pParams[nIndex].bOut) // inout
++                {
++                    uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
++                    uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
++                                            pThis->getBridge()->getCpp2Uno() );
++                }
++            }
++            else // pure out
++            {
++                uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
++                                        pThis->getBridge()->getCpp2Uno() );
++            }
++            // destroy temp cpp param => cpp: every param was constructed
++            uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
++            
++            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++        }
++        // return value
++        if (pCppReturn && pUnoReturn != pCppReturn)
++        {
++            uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
++                                    pThis->getBridge()->getCpp2Uno() );
++            uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
++        }
++    }
++    catch (...)
++    {
++        // fill uno exception
++        fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, 
++            *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
++
++        
++        // temporary params
++        for ( ; nTempIndizes--; )
++        {
++            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++            // destroy temp cpp param => cpp: every param was constructed
++            uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
++            TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
++        }
++        // return type
++        if (pReturnTypeDescr)
++            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
++    }
++}
++}
++
++namespace bridges { namespace cpp_uno { namespace shared {
++
++void unoInterfaceProxyDispatch(
++    uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
++    void * pReturn, void * pArgs[], uno_Any ** ppException )
++{
++#ifdef CMC_DEBUG
++    fprintf(stderr, "unoInterfaceProxyDispatch\n");
++#endif
++    
++
++    // is my surrogate
++    bridges::cpp_uno::shared::UnoInterfaceProxy * pThis 
++            = static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy *> (pUnoI);
++    
++    switch (pMemberDescr->eTypeClass)
++    {
++    case typelib_TypeClass_INTERFACE_ATTRIBUTE:
++    {
++
++        VtableSlot aVtableSlot(
++            getVtableSlot(
++                reinterpret_cast<
++                    typelib_InterfaceAttributeTypeDescription const * >(
++                        pMemberDescr)));
++
++        if (pReturn)
++        {
++            // dependent dispatch
++            cpp_call(
++                pThis, aVtableSlot,
++                ((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
++                0, 0, // no params
++                pReturn, pArgs, ppException );
++        }
++        else
++        {
++            // is SET
++            typelib_MethodParameter aParam;
++            aParam.pTypeRef =
++                ((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
++            aParam.bIn      = sal_True;
++            aParam.bOut     = sal_False;
++
++            typelib_TypeDescriptionReference * pReturnTypeRef = 0;
++            OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
++            typelib_typedescriptionreference_new(
++                &pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
++            
++            // dependent dispatch
++                        aVtableSlot.index += 1; //get then set method
++            cpp_call(
++                pThis, aVtableSlot,
++                pReturnTypeRef,
++                1, &aParam,
++                pReturn, pArgs, ppException );
++            
++            typelib_typedescriptionreference_release( pReturnTypeRef );
++        }
++        
++        break;
++    }
++    case typelib_TypeClass_INTERFACE_METHOD:
++    {
++
++        VtableSlot aVtableSlot(
++            getVtableSlot(
++                reinterpret_cast<
++                    typelib_InterfaceMethodTypeDescription const * >(
++                        pMemberDescr)));
++        switch (aVtableSlot.index)
++        {
++            // standard calls
++        case 1: // acquire uno interface
++            (*pUnoI->acquire)( pUnoI );
++            *ppException = 0;
++            break;
++        case 2: // release uno interface
++            (*pUnoI->release)( pUnoI );
++            *ppException = 0;
++            break;
++        case 0: // queryInterface() opt
++        {
++            typelib_TypeDescription * pTD = 0;
++            TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
++            if (pTD)
++            {
++                uno_Interface * pInterface = 0;
++                (*pThis->pBridge->getUnoEnv()->getRegisteredInterface)(
++                    pThis->pBridge->getUnoEnv(),
++                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
++            
++                if (pInterface)
++                {
++                    ::uno_any_construct(
++                        reinterpret_cast< uno_Any * >( pReturn ),
++                        &pInterface, pTD, 0 );
++                    (*pInterface->release)( pInterface );
++                    TYPELIB_DANGER_RELEASE( pTD );
++                    *ppException = 0;
++                    break;
++                }
++                TYPELIB_DANGER_RELEASE( pTD );
++            }
++        } // else perform queryInterface()
++        default:
++            // dependent dispatch
++            cpp_call(
++                pThis, aVtableSlot,
++                ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
++                ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
++                ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
++                pReturn, pArgs, ppException );
++        }
++        break;
++    }
++    default:
++    {
++        ::com::sun::star::uno::RuntimeException aExc(
++            OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
++            ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
++        
++        Type const & rExcType = ::getCppuType( &aExc );
++        // binary identical null reference
++        ::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
++    }
++    }
++}
++
++} } }
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r f387649cb501 idlc/source/preproc/cpp.h
+--- idlc/source/preproc/cpp.h	Fri Mar 12 15:32:45 2010 +0100
++++ idlc/source/preproc/cpp.h	Mon Mar 15 16:00:09 2010 +0000
+@@ -40,11 +40,8 @@
+ #define NULL	0
+ #endif
+ 
+-#ifndef __alpha
+ typedef unsigned char uchar;
+ 
+-#endif
+-
+ enum toktype
+ {
+     END, UNCLASS, NAME, NUMBER, STRING, CCON, NL, WS, DSHARP,
+diff -r f387649cb501 jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx
+--- jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	Fri Mar 12 15:32:45 2010 +0100
++++ jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -69,9 +69,11 @@
+ #define JFW_PLUGIN_ARCH "m68k"
+ #elif defined HPPA
+ #define JFW_PLUGIN_ARCH "parisc"
+-#else // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA
++#elif defined AXP
++#define JFW_PLUGIN_ARCH "alpha"
++#else // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA, ALPHA
+ #error unknown plattform
+-#endif // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA
++#endif // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA, ALPHA
+ 
+ 
+ class MalformedVersionException
+diff -r f387649cb501 sal/rtl/source/macro.hxx
+--- sal/rtl/source/macro.hxx	Fri Mar 12 15:32:45 2010 +0100
++++ sal/rtl/source/macro.hxx	Mon Mar 15 16:00:09 2010 +0000
+@@ -89,6 +89,8 @@
+ #    define THIS_ARCH "M68K"
+ #elif defined HPPA
+ #    define THIS_ARCH "HPPA"
++#elif defined AXP
++#    define THIS_ARCH "ALPHA"
+ #endif
+ 
+ #if ! defined THIS_ARCH
+diff -r f387649cb501 sal/typesconfig/typesconfig.c
+--- sal/typesconfig/typesconfig.c	Fri Mar 12 15:32:45 2010 +0100
++++ sal/typesconfig/typesconfig.c	Mon Mar 15 16:00:09 2010 +0000
+@@ -160,7 +160,7 @@
+ |*	Letzte Aenderung
+ |*
+ *************************************************************************/
+-#if defined(IA64) || defined(ARM32) || defined(HPPA)
++#if defined(IA64) || defined(ARM32) || defined(HPPA) || defined(AXP)
+ 
+ int forceerror()
+ {
+diff -r f387649cb501 set_soenv.in
+--- set_soenv.in	Fri Mar 12 15:32:45 2010 +0100
++++ set_soenv.in	Mon Mar 15 16:00:09 2010 +0000
+@@ -509,9 +509,9 @@
+    elsif ($platform =~ m/^alpha/) 
+    {  print "Setting Linux Alpha specific values... ";
+       $outfile        = "LinuxAlphaEnv.Set"; 
+-      $CPU            = "A";
+-      $CPUNAME        = "ALPHA_";
+-      $OUTPATH        = "unxlnga";
++      $CPU            = "L";
++      $CPUNAME        = "AXP";
++      $OUTPATH        = "unxlngaxp";
+       $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha";
+       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha".$ds."server";
+       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha".$ds."native_threads";
+diff -r f387649cb501 solenv/inc/unx.mk
+--- solenv/inc/unx.mk	Fri Mar 12 15:32:45 2010 +0100
++++ solenv/inc/unx.mk	Mon Mar 15 16:00:09 2010 +0000
+@@ -167,6 +167,10 @@
+ .INCLUDE : unxlnghppa.mk
+ .ENDIF
+ 
++.IF "$(COM)$(OS)$(CPU)" == "GCCLINUXL"
++.INCLUDE : unxlngaxp.mk
++.ENDIF
++
+ # --- general *ix settings ---
+ HC=hc
+ HCFLAGS=
+diff -r f387649cb501 solenv/inc/unxlngaxp.mk
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ solenv/inc/unxlngaxp.mk	Mon Mar 15 16:00:09 2010 +0000
+@@ -0,0 +1,34 @@
++#*************************************************************************
++#
++# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++# 
++# Copyright 2000, 2010 Oracle and/or its affiliates.
++#
++# OpenOffice.org - a multi-platform office productivity suite
++#
++# This file is part of OpenOffice.org.
++#
++# OpenOffice.org is free software: you can redistribute it and/or modify
++# it under the terms of the GNU Lesser General Public License version 3
++# only, as published by the Free Software Foundation.
++#
++# OpenOffice.org is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU Lesser General Public License version 3 for more details
++# (a copy is included in the LICENSE file that accompanied this code).
++#
++# You should have received a copy of the GNU Lesser General Public License
++# version 3 along with OpenOffice.org.  If not, see
++# <http://www.openoffice.org/license.html>
++# for a copy of the LGPLv3 License.
++#
++#*************************************************************************
++
++# mk file for Unix Linux Alpha using gcc, please make generic modifications to unxlng.mk
++
++PICSWITCH:=-fPIC
++.INCLUDE : unxlng.mk
++CFLAGS+=-DAXP
++DLLPOSTFIX=ll
++BUILD64=1
+diff -r f387649cb501 soltools/cpp/cpp.h
+--- soltools/cpp/cpp.h	Fri Mar 12 15:32:45 2010 +0100
++++ soltools/cpp/cpp.h	Mon Mar 15 16:00:09 2010 +0000
+@@ -15,11 +15,8 @@
+ #define NULL	0
+ #endif
+ 
+-#ifndef __alpha
+ typedef unsigned char uchar;
+ 
+-#endif
+-
+ enum toktype
+ {
+     END, UNCLASS, NAME, NUMBER, STRING, CCON, NL, WS, DSHARP,
+diff -r f387649cb501 tools/inc/tools/solar.h
+--- tools/inc/tools/solar.h	Fri Mar 12 15:32:45 2010 +0100
++++ tools/inc/tools/solar.h	Mon Mar 15 16:00:09 2010 +0000
+@@ -384,6 +384,8 @@
+   #define __DLLEXTENSION "lm.so"
+ #elif defined LINUX && defined HPPA
+   #define __DLLEXTENSION "lh.so"
++#elif defined LINUX && defined AXP
++  #define __DLLEXTENSION "ll.so"
+ #elif defined LINUX
+   #error unknown plattform
+ #elif defined FREEBSD && defined X86
