From: Douglas Mencken <dougmencken@gmail.com>
Date: Mon, 16 Dec 2013 09:34:58 -0500
Subject: [PATCH] Use sal_Int32 to satisfy oox/helper/helper.hxx's
 convertLittleEndian

Fixes build error "no matching function for call to oox::ByteOrderConverter::convertLittleEndian(int&)"

workaround rather maddening endian-specific template bustage

together these two master patches hopefully fix the PPC build

(also includes: Change-Id: I69dc97c93ef5efe8d71074ac3eca06a3bbc45253)

Change-Id: I899f151ff99737247ce4090f59897eba842c40ba
Reviewed-on: https://gerrit.libreoffice.org/7099
Reviewed-on: https://gerrit.libreoffice.org/7607
Reviewed-by: Michael Stahl <mstahl@redhat.com>
Tested-by: Michael Stahl <mstahl@redhat.com>

---
 oox/source/crypto/AgileEngine.cxx        |  2 +-
 oox/source/crypto/DocumentDecryption.cxx | 17 +++++++++++++++--
 oox/source/crypto/Standard2007Engine.cxx |  2 +-
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/oox/source/crypto/AgileEngine.cxx b/oox/source/crypto/AgileEngine.cxx
--- a/oox/source/crypto/AgileEngine.cxx
+++ b/oox/source/crypto/AgileEngine.cxx
@@ -106,7 +106,7 @@ bool AgileEngine::calculateHashFinal(const OUString& rPassword, vector<sal_uInt8
 
     vector<sal_uInt8> data(mInfo.hashSize + 4, 0);
 
-    for (int i = 0; i < mInfo.spinCount; i++)
+    for (sal_Int32 i = 0; i < mInfo.spinCount; i++)
     {
         ByteOrderConverter::writeLittleEndian( &data[0], i );
         std::copy(hash.begin(), hash.end(), data.begin() + 4);
diff --git a/oox/source/crypto/DocumentDecryption.cxx b/oox/source/crypto/DocumentDecryption.cxx
--- a/oox/source/crypto/DocumentDecryption.cxx
+++ b/oox/source/crypto/DocumentDecryption.cxx
@@ -289,9 +289,22 @@ bool DocumentDecryption::readStandard2007EncryptionInfo(BinaryInputStream& rStre
     if( (nHeaderSize < actualHeaderSize) )
         return false;
 
-    rStream >> info.header;
+    rStream >> info.header.flags;
+    rStream >> info.header.sizeExtra;
+    rStream >> info.header.algId;
+    rStream >> info.header.algIdHash;
+    rStream >> info.header.keyBits;
+    rStream >> info.header.providedType;
+    rStream >> info.header.reserved1;
+    rStream >> info.header.reserved2;
+
     rStream.skip( nHeaderSize - actualHeaderSize );
-    rStream >> info.verifier;
+
+    rStream >> info.verifier.saltSize;
+    rStream.readArray(info.verifier.salt, SAL_N_ELEMENTS(info.verifier.salt));
+    rStream.readArray(info.verifier.encryptedVerifier, SAL_N_ELEMENTS(info.verifier.encryptedVerifier));
+    rStream >> info.verifier.encryptedVerifierHashSize;
+    rStream.readArray(info.verifier.encryptedVerifierHash, SAL_N_ELEMENTS(info.verifier.encryptedVerifierHash));
 
     if( info.verifier.saltSize != 16 )
         return false;
diff --git a/oox/source/crypto/Standard2007Engine.cxx b/oox/source/crypto/Standard2007Engine.cxx
--- a/oox/source/crypto/Standard2007Engine.cxx
+++ b/oox/source/crypto/Standard2007Engine.cxx
@@ -129,7 +129,7 @@ bool Standard2007Engine::calculateEncryptionKey(const OUString& rPassword)
     // data = iterator (4bytes) + hash
     vector<sal_uInt8> data(RTL_DIGEST_LENGTH_SHA1 + 4, 0);
 
-    for (int i = 0; i < 50000; i++)
+    for (sal_Int32 i = 0; i < 50000; ++i)
     {
         ByteOrderConverter::writeLittleEndian( &data[0], i );
         std::copy(hash.begin(), hash.end(), data.begin() + 4);
-- 
1.8.3.2

