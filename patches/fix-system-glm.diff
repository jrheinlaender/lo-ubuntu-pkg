diff --git a/chart2/source/view/charttypes/GL3DBarChart.cxx b/chart2/source/view/charttypes/GL3DBarChart.cxx
index 542711a..2f96bab 100644
--- a/chart2/source/view/charttypes/GL3DBarChart.cxx
+++ b/chart2/source/view/charttypes/GL3DBarChart.cxx
@@ -119,8 +119,8 @@ void GL3DBarChart::create3DShapes(const boost::ptr_vector<VDataSeries>& rDataSer
             float nXPos = nIndex * (nBarSizeX + nBarDistanceX);
 
 
-            glm::mat4 aScaleMatrix = glm::scale(nBarSizeX, nBarSizeY, nVal);
-            glm::mat4 aTranslationMatrix = glm::translate(nXPos, nYPos, 0.0f);
+            glm::mat4 aScaleMatrix = glm::scale(glm::vec3(nBarSizeX, nBarSizeY, nVal));
+            glm::mat4 aTranslationMatrix = glm::translate(glm::vec3(nXPos, nYPos, 0.0f));
             glm::mat4 aBarPosition = aTranslationMatrix * aScaleMatrix;
 
             maShapes.push_back(new opengl3D::Bar(mpRenderer.get(), aBarPosition, nColor, nId++));
diff --git a/chart2/source/view/main/GL3DRenderer.cxx b/chart2/source/view/main/GL3DRenderer.cxx
index d6c1dff..3d5e79f 100644
--- a/chart2/source/view/main/GL3DRenderer.cxx
+++ b/chart2/source/view/main/GL3DRenderer.cxx
@@ -984,7 +984,7 @@ void OpenGL3DRenderer::AddShape3DExtrudeObject(bool roundedCorner, sal_uInt32 nC
     m_Extrude3DInfo.yScale = glm::length(DirY);
     m_Extrude3DInfo.zScale = glm::length(DirZ);
     glm::mat4 transformMatrixInverse = glm::inverse(glm::translate(glm::vec3(tranform)));
-    glm::mat4 scaleMatrixInverse = glm::inverse(glm::scale(m_Extrude3DInfo.xScale, m_Extrude3DInfo.yScale, m_Extrude3DInfo.zScale * crossZ));
+    glm::mat4 scaleMatrixInverse = glm::inverse(glm::scale(glm::vec3(m_Extrude3DInfo.xScale, m_Extrude3DInfo.yScale, m_Extrude3DInfo.zScale * crossZ)));
     m_Extrude3DInfo.rotation = transformMatrixInverse * modelMatrix * scaleMatrixInverse;
     //color
     m_Extrude3DInfo.extrudeColor = getColorAsVector(nColor);
@@ -1090,7 +1090,7 @@ void OpenGL3DRenderer::RenderExtrudeFlatSurface(const Extrude3DInfo& extrude3D,
                       extrude3D.yTransform,
                       extrude3D.zTransform};
     glm::mat4 aTranslationMatrix = glm::translate(glm::vec3(trans.x, trans.y, trans.z));
-    glm::mat4 flatScale = glm::scale(xyScale, xyScale, xyScale);
+    glm::mat4 flatScale = glm::scale(glm::vec3(xyScale, xyScale, xyScale));
     m_Model = aTranslationMatrix * extrude3D.rotation * flatScale;
     if(!mbPickingMode)
     {
@@ -1131,7 +1131,7 @@ void OpenGL3DRenderer::RenderExtrudeBottomSurface(const Extrude3DInfo& extrude3D
     else
     {
         glm::mat4 topTrans = glm::translate(glm::vec3(0.0, 0.0, -actualZTrans));
-        glm::mat4 topScale = glm::scale(xyScale, xyScale, xyScale);
+        glm::mat4 topScale = glm::scale(glm::vec3(xyScale, xyScale, xyScale));
         glm::mat4 aTranslationMatrix = glm::translate(glm::vec3(trans.x, trans.y, trans.z));
         m_Model = aTranslationMatrix * extrude3D.rotation * topTrans * topScale;
     }
@@ -1170,7 +1170,7 @@ void OpenGL3DRenderer::RenderExtrudeMiddleSurface(const Extrude3DInfo& extrude3D
     }
     else
     {
-        glm::mat4 scale = glm::scale(xyScale, xyScale,actualZScale);
+        glm::mat4 scale = glm::scale(glm::vec3(xyScale, xyScale,actualZScale));
         glm::mat4 aTranslationMatrix = glm::translate(glm::vec3(trans.x, trans.y, trans.z));
         m_Model = aTranslationMatrix * extrude3D.rotation * scale;
     }
@@ -1212,7 +1212,7 @@ void OpenGL3DRenderer::RenderExtrudeTopSurface(const Extrude3DInfo& extrude3D)
         //yScale /= (float)(1 + BOTTOM_THRESHOLD);
         zScale /= (float)(m_RoundBarMesh.bottomThreshold);
         glm::mat4 orgTrans = glm::translate(glm::vec3(0.0, 0.0, -1.0));
-        glm::mat4 scale = glm::scale(xyScale, xyScale, zScale);
+        glm::mat4 scale = glm::scale(glm::vec3(xyScale, xyScale, zScale));
         //MoveModelf(trans, angle, scale);
         glm::mat4 aTranslationMatrix = glm::translate(glm::vec3(trans.x, trans.y, trans.z));
         m_Model = aTranslationMatrix * extrude3D.rotation * scale * orgTrans;
@@ -1222,7 +1222,7 @@ void OpenGL3DRenderer::RenderExtrudeTopSurface(const Extrude3DInfo& extrude3D)
         // use different matrices for different parts
         glm::mat4 orgTrans = glm::translate(glm::vec3(0.0, 0.0, -1.0));
         glm::mat4 topTrans = glm::translate(glm::vec3(0.0, 0.0, actualZTrans));
-        glm::mat4 topScale = glm::scale(xyScale, xyScale, xyScale);
+        glm::mat4 topScale = glm::scale(glm::vec3(xyScale, xyScale, xyScale));
         glm::mat4 aTranslationMatrix = glm::translate(glm::vec3(trans.x, trans.y, trans.z));
         m_Model = aTranslationMatrix * extrude3D.rotation * topTrans * topScale * orgTrans;
     }
@@ -1250,7 +1250,7 @@ void OpenGL3DRenderer::RenderNonRoundedBar(const Extrude3DInfo& extrude3D)
     float yScale = extrude3D.yScale;
     float zScale = extrude3D.zScale;
     glm::mat4 transformMatrix = glm::translate(glm::vec3(extrude3D.xTransform, extrude3D.yTransform, extrude3D.zTransform));
-    glm::mat4 scaleMatrix = glm::scale(xScale, yScale, zScale);
+    glm::mat4 scaleMatrix = glm::scale(glm::vec3(xScale, yScale, zScale));
     m_Model = transformMatrix * extrude3D.rotation * scaleMatrix;
     if (extrude3D.reverse)
     {
