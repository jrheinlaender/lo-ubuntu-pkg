From: Bjoern Michaelsen <bjoern.michaelsen@canonical.com>
Date: Sun, 18 May 2014 14:28:39 +0200
Subject: [PATCH] lp#1296715: refresh invalidated menus

- so we need to be a StatusListener in framework after all
- we ware updating all menus for now, instead of just one
- this would have a hugh performance hit when there is much change to the menu
- thus we just invalidate the menu and update with all changes after 100ms once

Change-Id: I48cda968cf0ae1eae0421b3424bb3e5830817e84

---
 framework/source/uielement/menubarmanager.cxx |  6 ++++
 include/vcl/helper.hxx                        |  3 ++
 include/vcl/menu.hxx                          | 12 +++++++
 vcl/source/window/menu.cxx                    | 17 ++++++++++
 vcl/unx/gtk/window/gtksalmenu.cxx             | 45 +++++++++++++++++++++++++++
 5 files changed, 83 insertions(+)

diff --git a/framework/source/uielement/menubarmanager.cxx b/framework/source/uielement/menubarmanager.cxx
--- a/framework/source/uielement/menubarmanager.cxx
+++ b/framework/source/uielement/menubarmanager.cxx
@@ -67,6 +67,7 @@
 #include <toolkit/helper/vclunohelper.hxx>
 #include <vcl/svapp.hxx>
 #include <vcl/window.hxx>
+#include <vcl/menu.hxx>
 #include <vcl/settings.hxx>
 #include <osl/mutex.hxx>
 #include <osl/file.hxx>
@@ -430,6 +431,10 @@ throw ( RuntimeException, std::exception )
 
     SolarMutexGuard aSolarGuard;
     {
+        vcl::MenuInvalidator aInvalidator;
+        aInvalidator.Invalidated();
+    }
+    {
         if ( m_bDisposed )
             return;
 
@@ -917,6 +922,7 @@ IMPL_LINK( MenuBarManager, Activate, Menu *, pMenu )
                                     // We need only an update to reflect the current state
                                     xMenuItemDispatch->addStatusListener( static_cast< XStatusListener* >( this ), aTargetURL );
                                     xMenuItemDispatch->removeStatusListener( static_cast< XStatusListener* >( this ), aTargetURL );
+                                    xMenuItemDispatch->addStatusListener( static_cast< XStatusListener* >( this ), aTargetURL );
                                 }
                             }
                             else if ( !bPopupMenu )
diff --git a/include/vcl/helper.hxx b/include/vcl/helper.hxx
--- a/include/vcl/helper.hxx
+++ b/include/vcl/helper.hxx
@@ -54,6 +54,9 @@ enum whichOfficePath { InstallationRootPath, UserPath, ConfigPath };
 OUString VCL_DLLPUBLIC getOfficePath( enum whichOfficePath ePath );
 } // namespace
 
+
+#include <vcl/vclevent.hxx>
+bool VCL_DLLPUBLIC GetMenuInvalidateListeners();
 #endif // INCLUDED_VCL_HELPER_HXX
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/include/vcl/menu.hxx b/include/vcl/menu.hxx
--- a/include/vcl/menu.hxx
+++ b/include/vcl/menu.hxx
@@ -359,6 +359,18 @@ public:
 };
 
 
+#include <vcl/vclevent.hxx>
+namespace vcl
+{
+    class VCL_DLLPUBLIC MenuInvalidator
+    {
+        public:
+            MenuInvalidator();
+            VclEventListeners2* GetMenuInvalidateListeners();
+            void Invalidated();
+    };
+}
+
 // - MenuBar -
 
 
diff --git a/vcl/source/window/menu.cxx b/vcl/source/window/menu.cxx
--- a/vcl/source/window/menu.cxx
+++ b/vcl/source/window/menu.cxx
@@ -6130,4 +6130,21 @@ ImplMenuDelData::~ImplMenuDelData()
         const_cast< Menu* >( mpMenu )->ImplRemoveDel( *this );
 }
 
+namespace vcl
+{
+    MenuInvalidator::MenuInvalidator() {};
+    
+    static VclEventListeners2* pMenuInvalidateListeners = NULL;
+    VclEventListeners2* MenuInvalidator::GetMenuInvalidateListeners()
+    {
+        if(!pMenuInvalidateListeners)
+            pMenuInvalidateListeners = new VclEventListeners2();
+        return pMenuInvalidateListeners;
+    }
+    void MenuInvalidator::Invalidated()
+    {
+        VclSimpleEvent aEvent(0);
+        GetMenuInvalidateListeners()->callListeners(&aEvent);
+    };
+}
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/unx/gtk/window/gtksalmenu.cxx b/vcl/unx/gtk/window/gtksalmenu.cxx
--- a/vcl/unx/gtk/window/gtksalmenu.cxx
+++ b/vcl/unx/gtk/window/gtksalmenu.cxx
@@ -448,9 +448,15 @@ void GtkSalMenu::SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsig
     pItem->mpSubMenu = pGtkSubMenu;
 }
 
+#include <vcl/menu.hxx>
+Link* getRefreshLinkInstance();
 void GtkSalMenu::SetFrame( const SalFrame* pFrame )
 {
     SolarMutexGuard aGuard;
+    {
+        vcl::MenuInvalidator aInvalidator;
+        aInvalidator.GetMenuInvalidateListeners()->addListener(*getRefreshLinkInstance());
+    }
 
     assert(mbMenuBar);
     SAL_INFO("vcl.unity", "GtkSalMenu set to frame");
@@ -798,6 +804,45 @@ GtkSalMenuItem::~GtkSalMenuItem()
 {
 }
 
+#include <generic/gendata.hxx>
+#include <unx/saldisp.hxx>
+static bool bInvalidMenus = false;
+gboolean RefreshMenusUnity(gpointer)
+{
+    SalDisplay* pSalDisplay = GetGenericData()->GetSalDisplay();
+    std::list< SalFrame* >::const_iterator pSalFrame = pSalDisplay->getFrames().begin();
+    std::list< SalFrame* >::const_iterator pEndSalFrame = pSalDisplay->getFrames().end();
+    for(; pSalFrame != pEndSalFrame; ++pSalFrame) {
+        const GtkSalFrame* pGtkSalFrame = static_cast< const GtkSalFrame* >( *pSalFrame );
+        GtkSalFrame* pFrameNonConst = const_cast<GtkSalFrame*>(pGtkSalFrame);
+        GtkSalMenu* pSalMenu = static_cast<GtkSalMenu*>(pFrameNonConst->GetMenu());
+        if(pSalMenu) {
+            pSalMenu->Activate();
+            pSalMenu->UpdateFull();
+        }
+    }
+    bInvalidMenus = false;
+    return FALSE;
+}
+
+long RefreshMenusUnity(void*, void*)
+{
+    if(!bInvalidMenus) {
+        g_timeout_add(10, &RefreshMenusUnity, NULL);
+        bInvalidMenus = true;
+    }
+    return 0;
+}
+
+Link* getRefreshLinkInstance()
+{
+    static Link* pLink = NULL;
+    if(!pLink) {
+        pLink = new Link(NULL, &RefreshMenusUnity);
+    }
+    return pLink;
+}
+
 #endif
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
-- 
1.9.1

