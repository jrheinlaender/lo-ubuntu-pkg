commit e9db2efab56f37b59fc10da18af73d9cf09846d8
Author: Antonio Fernández <antonio.fernandez@aentos.es>
Date:   Mon Aug 27 14:38:15 2012 +0100

    Radio button action data is now properly set.
    
    Change-Id: Icbd44308631278e6ab65cef123d4d32befff87fc
 framework/inc/classes/menumanager.hxx         |   22 +-
 framework/inc/uielement/menubarmanager.hxx    |   24 +-
 framework/inc/uielement/menubarmerger.hxx     |   16 +-
 framework/inc/uielement/menubarwrapper.hxx    |    1 +
 framework/source/classes/menumanager.cxx      |   16 +-
 framework/source/uielement/menubarmanager.cxx |   40 +-
 framework/source/uielement/menubarmerger.cxx  |   18 +-
 framework/source/uielement/menubarwrapper.cxx |   16 +
 vcl/Library_vcl.mk                            |    1 +
 vcl/Library_vclplug_gtk.mk                    |   11 +-
 vcl/Library_vclplug_gtk3.mk                   |    3 +
 vcl/inc/salmenu.hxx                           |    7 +-
 vcl/inc/unx/gtk/gloactiongroup.h              |   99 ++++
 vcl/inc/unx/gtk/glomenu.h                     |  114 +++++
 vcl/inc/unx/gtk/gtkinst.hxx                   |    4 +
 vcl/inc/unx/gtk/gtksalmenu.hxx                |  108 ++++
 vcl/inc/unx/salmenu.h                         |    8 +-
 vcl/inc/vcl/menu.hxx                          |  156 ++++--
 vcl/source/window/menu.cxx                    |   21 +-
 vcl/unx/gtk/app/gtkinst.cxx                   |   29 ++
 vcl/unx/gtk/window/gloactiongroup.cxx         |  441 +++++++++++++++++
 vcl/unx/gtk/window/glomenu.cxx                |  488 ++++++++++++++++++
 vcl/unx/gtk/window/gtksalmenu.cxx             |  660 +++++++++++++++++++++++++
 vcl/unx/gtk3/window/gtk3gloactiongroup.cxx    |    2 +
 vcl/unx/gtk3/window/gtk3glomenu.cxx           |    2 +
 vcl/unx/gtk3/window/gtk3gtksalmenu.cxx        |    2 +
 26 files changed, 2199 insertions(+), 110 deletions(-)
diff --git a/framework/inc/classes/menumanager.hxx b/framework/inc/classes/menumanager.hxx
index 3ac4588..56ecc90 100644
--- a/framework/inc/classes/menumanager.hxx
+++ b/framework/inc/classes/menumanager.hxx
@@ -78,7 +78,7 @@ class MenuManager : public ThreadHelpBase           ,
         MenuManager(
             const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceFactory,
             REFERENCE< XFRAME >& rFrame,
-            Menu* pMenu,
+            AbstractMenu* pMenu,
             sal_Bool bDelete,
             sal_Bool bDeleteChildren );
 
@@ -90,33 +90,33 @@ class MenuManager : public ThreadHelpBase           ,
         // XEventListener
         virtual void SAL_CALL disposing( const EVENTOBJECT& Source ) throw ( RUNTIMEEXCEPTION );
 
-        DECL_LINK( Select, Menu * );
+        DECL_LINK( Select, AbstractMenu * );
 
-        Menu*   GetMenu() const { return m_pVCLMenu; }
+        AbstractMenu*   GetMenu() const { return m_pVCLMenu; }
 
         void    RemoveListener();
 
         const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& getServiceFactory();
 
-        static void UpdateSpecialWindowMenu( Menu* pMenu ,const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceFactory,IMutex& _rMutex);
+        static void UpdateSpecialWindowMenu( AbstractMenu* pMenu ,const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceFactory,IMutex& _rMutex);
         static void FillMenuImages(
             ::com::sun::star::uno::Reference< com::sun::star::frame::XFrame >& xFrame,
-            Menu* _pMenu,
+            AbstractMenu* _pMenu,
             sal_Bool bShowMenuImages
         );
 
     protected:
         DECL_LINK(Highlight, void *);
-        DECL_LINK( Activate, Menu * );
-        DECL_LINK( Deactivate, Menu * );
+        DECL_LINK( Activate, AbstractMenu * );
+        DECL_LINK( Deactivate, AbstractMenu * );
 
     private:
-        void UpdateSpecialFileMenu( Menu* pMenu );
-        void UpdateSpecialWindowMenu( Menu* pMenu );
+        void UpdateSpecialFileMenu( AbstractMenu* pMenu );
+        void UpdateSpecialWindowMenu( AbstractMenu* pMenu );
         void ClearMenuDispatch(const EVENTOBJECT& Source = EVENTOBJECT(),bool _bRemoveOnly = true);
         void SetHdl();
         void AddMenu(PopupMenu* _pPopupMenu,const ::rtl::OUString& _sItemCommand,sal_uInt16 _nItemId,sal_Bool _bDelete,sal_Bool _bDeleteChildren);
-        sal_uInt16 FillItemCommand(::rtl::OUString& _rItemCommand,Menu* _pMenu,sal_uInt16 _nIndex) const;
+        sal_uInt16 FillItemCommand(::rtl::OUString& _rItemCommand, AbstractMenu* _pMenu,sal_uInt16 _nIndex) const;
 
 
         struct MenuItemHandler
@@ -147,7 +147,7 @@ class MenuManager : public ThreadHelpBase           ,
         sal_Bool                            m_bIsBookmarkMenu;
         sal_Bool                            m_bShowMenuImages;
         ::rtl::OUString                     m_aMenuItemCommand;
-        Menu*                               m_pVCLMenu;
+        AbstractMenu*                       m_pVCLMenu;
         REFERENCE< XFRAME >                 m_xFrame;
         ::std::vector< MenuItemHandler* >   m_aMenuItemHandlerVector;
 
diff --git a/framework/inc/uielement/menubarmanager.hxx b/framework/inc/uielement/menubarmanager.hxx
index 6836707..59273e8 100644
--- a/framework/inc/uielement/menubarmanager.hxx
+++ b/framework/inc/uielement/menubarmanager.hxx
@@ -120,7 +120,7 @@ class MenuBarManager : public com::sun::star::frame::XStatusListener
             const ::com::sun::star::uno::Reference< ::com::sun::star::util::XURLTransformer >& _xURLTransformer,
             const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XDispatchProvider >& rDispatchProvider,
             const rtl::OUString& aModuleIdentifier,
-            Menu* pMenu,
+            AbstractMenu* pMenu,
             sal_Bool bDelete,
             sal_Bool bDeleteChildren );
 
@@ -155,22 +155,22 @@ class MenuBarManager : public com::sun::star::frame::XStatusListener
         // XSystemDependentMenuPeer
         virtual ::com::sun::star::uno::Any SAL_CALL getMenuHandle( const ::com::sun::star::uno::Sequence< sal_Int8 >& ProcessId, sal_Int16 SystemType ) throw (::com::sun::star::uno::RuntimeException);
 
-        DECL_LINK( Select, Menu * );
+        DECL_LINK( Select, AbstractMenu * );
 
-        Menu*   GetMenuBar() const { return m_pVCLMenu; }
+        AbstractMenu*   GetMenuBar() const { return m_pVCLMenu; }
 
         // Configuration methods
-        static void FillMenuWithConfiguration( sal_uInt16& nId, Menu* pMenu,
+        static void FillMenuWithConfiguration( sal_uInt16& nId, AbstractMenu* pMenu,
                                                const ::rtl::OUString& rModuleIdentifier,
                                                const ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >& rItemContainer,
                                                const ::com::sun::star::uno::Reference< ::com::sun::star::util::XURLTransformer >& rTransformer );
         static void FillMenu( sal_uInt16& nId,
-                              Menu* pMenu,
+                              AbstractMenu* pMenu,
                               const ::rtl::OUString& rModuleIdentifier,
                               const ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >& rItemContainer,
                               const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XDispatchProvider >& rDispatchProvider );
 
-        void FillMenuManager( Menu* pMenu,
+        void FillMenuManager( AbstractMenu* pMenu,
                               const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XFrame >& rFrame,
                               const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XDispatchProvider >& rDispatchProvider,
                               const rtl::OUString& rModuleIdentifier,
@@ -181,8 +181,8 @@ class MenuBarManager : public com::sun::star::frame::XStatusListener
 
     protected:
         DECL_LINK(Highlight, void *);
-        DECL_LINK( Activate, Menu * );
-        DECL_LINK( Deactivate, Menu * );
+        DECL_LINK( Activate, AbstractMenu * );
+        DECL_LINK( Deactivate, AbstractMenu * );
         DECL_LINK( AsyncSettingsHdl, Timer * );
 
         void RemoveListener();
@@ -225,16 +225,16 @@ class MenuBarManager : public com::sun::star::frame::XStatusListener
         void             CreatePicklistArguments(
                             ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& aArgsList,
                             const MenuItemHandler* );
-        void             CheckAndAddMenuExtension( Menu* pMenu );
+        void             CheckAndAddMenuExtension( AbstractMenu* pMenu );
         static void      impl_RetrieveShortcutsFromConfiguration( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::XAcceleratorConfiguration >& rAccelCfg,
                                                                   const ::com::sun::star::uno::Sequence< rtl::OUString >& rCommands,
                                                                   std::vector< MenuItemHandler* >& aMenuShortCuts );
-        static void      MergeAddonMenus( Menu* pMenuBar, const MergeMenuInstructionContainer&, const ::rtl::OUString& aModuleIdentifier );
+        static void      MergeAddonMenus( AbstractMenu* pMenuBar, const MergeMenuInstructionContainer&, const ::rtl::OUString& aModuleIdentifier );
 
         MenuItemHandler* GetMenuItemHandler( sal_uInt16 nItemId );
         sal_Bool         CreatePopupMenuController( MenuItemHandler* pMenuItemHandler );
         void             AddMenu(MenuBarManager* pSubMenuManager,const ::rtl::OUString& _sItemCommand,sal_uInt16 _nItemId);
-        sal_uInt16           FillItemCommand(::rtl::OUString& _rItemCommand,Menu* _pMenu,sal_uInt16 _nIndex) const;
+        sal_uInt16           FillItemCommand(::rtl::OUString& _rItemCommand, AbstractMenu* _pMenu,sal_uInt16 _nIndex) const;
         void             Init(const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XFrame >& rFrame,AddonMenu* pAddonMenu,sal_Bool bDelete,sal_Bool bDeleteChildren,bool _bHandlePopUp = false);
         void             SetHdl();
 
@@ -250,7 +250,7 @@ class MenuBarManager : public com::sun::star::frame::XStatusListener
         sal_Bool                                                                               m_bModuleIdentified;
         ::rtl::OUString                                                                        m_aMenuItemCommand;
         ::rtl::OUString                                                                        m_aModuleIdentifier;
-        Menu*                                                                                  m_pVCLMenu;
+        AbstractMenu*                                                                          m_pVCLMenu;
         ::com::sun::star::uno::Reference< ::com::sun::star::frame::XFrame >                    m_xFrame;
         ::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess >           m_xUICommandLabels;
         ::com::sun::star::uno::Reference< ::com::sun::star::frame::XUIControllerRegistration > m_xPopupMenuControllerRegistration;
diff --git a/framework/inc/uielement/menubarmerger.hxx b/framework/inc/uielement/menubarmerger.hxx
index 869e031..17a2b3f 100644
--- a/framework/inc/uielement/menubarmerger.hxx
+++ b/framework/inc/uielement/menubarmerger.hxx
@@ -60,7 +60,7 @@ enum RPResultInfo
 
 struct ReferencePathInfo
 {
-    Menu*              pPopupMenu;
+    AbstractMenu*      pPopupMenu;
     sal_uInt16         nPos;
     sal_Int32          nLevel;
     RPResultInfo       eResult;
@@ -73,14 +73,14 @@ class MenuBarMerger
 
         static void       RetrieveReferencePath( const ::rtl::OUString&,
                                                  std::vector< ::rtl::OUString >& aReferencePath );
-        static ReferencePathInfo FindReferencePath( const std::vector< ::rtl::OUString >& aReferencePath, Menu* pMenu );
+        static ReferencePathInfo FindReferencePath( const std::vector< ::rtl::OUString >& aReferencePath, AbstractMenu* pMenu );
         static sal_uInt16 FindMenuItem( const ::rtl::OUString& rCmd,
-                                        Menu* pMenu );
+                                        AbstractMenu* pMenu );
         static void       GetMenuEntry( const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& rAddonMenuEntry,
                                         AddonMenuItem& aAddonMenu );
         static void       GetSubMenu( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > >& rSubMenuEntries,
                                       AddonMenuContainer& rSubMenu );
-        static bool       ProcessMergeOperation( Menu*                     pMenu,
+        static bool       ProcessMergeOperation( AbstractMenu*             pMenu,
                                                  sal_uInt16                nPos,
                                                  sal_uInt16&               rItemId,
                                                  const ::rtl::OUString&    rMergeCommand,
@@ -95,21 +95,21 @@ class MenuBarMerger
                                                     const ::rtl::OUString&                  rModuleIdentifier,
                                                     const AddonMenuContainer&               rAddonMenuItems );
         static bool       ProcessFallbackOperation();
-        static bool       MergeMenuItems( Menu*                     pMenu,
+        static bool       MergeMenuItems( AbstractMenu*             pMenu,
                                           sal_uInt16                nPos,
                                           sal_uInt16                nModIndex,
                                           sal_uInt16&               rItemId,
                                           const ::rtl::OUString&    rModuleIdentifier,
                                           const AddonMenuContainer& rAddonMenuItems );
-        static bool       ReplaceMenuItem( Menu*                     pMenu,
+        static bool       ReplaceMenuItem( AbstractMenu*             pMenu,
                                            sal_uInt16                nPos,
                                            sal_uInt16&               rItemId,
                                            const ::rtl::OUString&    rModuleIdentifier,
                                            const AddonMenuContainer& rAddonMenuItems );
-        static bool       RemoveMenuItems( Menu*                     pMenu,
+        static bool       RemoveMenuItems( AbstractMenu*             pMenu,
                                            sal_uInt16                nPos,
                                            const ::rtl::OUString&    rMergeCommandParameter );
-        static bool       CreateSubMenu( Menu*                     pSubMenu,
+        static bool       CreateSubMenu( AbstractMenu*             pSubMenu,
                                          sal_uInt16&               nItemId,
                                          const ::rtl::OUString&    rModuleIdentifier,
                                          const AddonMenuContainer& rAddonSubMenu );
diff --git a/framework/inc/uielement/menubarwrapper.hxx b/framework/inc/uielement/menubarwrapper.hxx
index 7aa5c0a..3ef24f0 100644
--- a/framework/inc/uielement/menubarwrapper.hxx
+++ b/framework/inc/uielement/menubarwrapper.hxx
@@ -96,6 +96,7 @@ class MenuBarWrapper : public UIConfigElementWrapperBase,
     private:
         virtual void impl_fillNewData();
         void fillPopupControllerCache();
+//        void GenerateFullMenuBar( MenuBar *pMenuBar );
 
         sal_Bool                                                                                m_bRefreshPopupControllerCache : 1;
         com::sun::star::uno::Reference< com::sun::star::lang::XComponent >                      m_xMenuBarManager;
diff --git a/framework/source/classes/menumanager.cxx b/framework/source/classes/menumanager.cxx
index 8319bec..bf9a1e4 100644
--- a/framework/source/classes/menumanager.cxx
+++ b/framework/source/classes/menumanager.cxx
@@ -134,7 +134,7 @@ const char UNO_COMMAND[] = ".uno:";
 
 MenuManager::MenuManager(
     const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceFactory,
-    REFERENCE< XFRAME >& rFrame, Menu* pMenu, sal_Bool bDelete, sal_Bool bDeleteChildren )
+    REFERENCE< XFRAME >& rFrame, AbstractMenu* pMenu, sal_Bool bDelete, sal_Bool bDeleteChildren )
 :
     ThreadHelpBase( &Application::GetSolarMutex() ),
     mxServiceFactory(xServiceFactory)
@@ -479,7 +479,7 @@ void SAL_CALL MenuManager::disposing( const EVENTOBJECT& Source ) throw ( RUNTIM
 }
 
 
-void MenuManager::UpdateSpecialFileMenu( Menu* pMenu )
+void MenuManager::UpdateSpecialFileMenu( AbstractMenu* pMenu )
 {
     // update picklist
     Sequence< Sequence< PropertyValue > > aHistoryList = SvtHistoryOptions().GetList( ePICKLIST );
@@ -645,7 +645,7 @@ void MenuManager::UpdateSpecialFileMenu( Menu* pMenu )
     }
 }
 
-void MenuManager::UpdateSpecialWindowMenu( Menu* pMenu,const Reference< XMultiServiceFactory >& xServiceFactory,framework::IMutex& _rMutex )
+void MenuManager::UpdateSpecialWindowMenu( AbstractMenu* pMenu,const Reference< XMultiServiceFactory >& xServiceFactory,framework::IMutex& _rMutex )
 {
     // update window list
     ::std::vector< ::rtl::OUString > aNewWindowListVector;
@@ -759,7 +759,7 @@ void MenuManager::CreatePicklistArguments( Sequence< PropertyValue >& aArgsList,
 // vcl handler
 //_________________________________________________________________________________________________________________
 
-IMPL_LINK( MenuManager, Activate, Menu *, pMenu )
+IMPL_LINK( MenuManager, Activate, AbstractMenu *, pMenu )
 {
     if ( pMenu == m_pVCLMenu )
     {
@@ -862,7 +862,7 @@ IMPL_LINK( MenuManager, Activate, Menu *, pMenu )
 }
 
 
-IMPL_LINK( MenuManager, Deactivate, Menu *, pMenu )
+IMPL_LINK( MenuManager, Deactivate, AbstractMenu *, pMenu )
 {
     if ( pMenu == m_pVCLMenu )
         m_bActive = sal_False;
@@ -871,7 +871,7 @@ IMPL_LINK( MenuManager, Deactivate, Menu *, pMenu )
 }
 
 
-IMPL_LINK( MenuManager, Select, Menu *, pMenu )
+IMPL_LINK( MenuManager, Select, AbstractMenu *, pMenu )
 {
     URL                     aTargetURL;
     Sequence<PropertyValue> aArgs;
@@ -973,7 +973,7 @@ void MenuManager::AddMenu(PopupMenu* _pPopupMenu,const ::rtl::OUString& _sItemCo
     m_aMenuItemHandlerVector.push_back( pMenuItemHandler );
 }
 
-sal_uInt16 MenuManager::FillItemCommand(::rtl::OUString& _rItemCommand,Menu* _pMenu,sal_uInt16 _nIndex) const
+sal_uInt16 MenuManager::FillItemCommand(::rtl::OUString& _rItemCommand, AbstractMenu* _pMenu,sal_uInt16 _nIndex) const
 {
     sal_uInt16 nItemId = _pMenu->GetItemId( _nIndex );
 
@@ -987,7 +987,7 @@ sal_uInt16 MenuManager::FillItemCommand(::rtl::OUString& _rItemCommand,Menu* _pM
     }
     return nItemId;
 }
-void MenuManager::FillMenuImages(Reference< XFrame >& _xFrame,Menu* _pMenu,sal_Bool bShowMenuImages)
+void MenuManager::FillMenuImages(Reference< XFrame >& _xFrame, AbstractMenu* _pMenu,sal_Bool bShowMenuImages)
 {
     AddonsOptions       aAddonOptions;
 
diff --git a/framework/source/uielement/menubarmanager.cxx b/framework/source/uielement/menubarmanager.cxx
index 4c64446..6f19829 100644
--- a/framework/source/uielement/menubarmanager.cxx
+++ b/framework/source/uielement/menubarmanager.cxx
@@ -196,7 +196,7 @@ MenuBarManager::MenuBarManager(
     const Reference< XURLTransformer >& _xURLTransformer,
     const Reference< XDispatchProvider >& rDispatchProvider,
     const rtl::OUString& rModuleIdentifier,
-    Menu* pMenu, sal_Bool bDelete, sal_Bool bDeleteChildren )
+    AbstractMenu* pMenu, sal_Bool bDelete, sal_Bool bDeleteChildren )
 : ThreadHelpBase( &Application::GetSolarMutex() ), OWeakObject()
     , m_bDisposed( sal_False )
     , m_bRetrieveImages( sal_False )
@@ -771,7 +771,7 @@ void SAL_CALL MenuBarManager::disposing( const EventObject& Source ) throw ( Run
 }
 
 
-void MenuBarManager::CheckAndAddMenuExtension( Menu* pMenu )
+void MenuBarManager::CheckAndAddMenuExtension( AbstractMenu* pMenu )
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::CheckAndAddMenuExtension" );
     static const char REFERENCECOMMAND_BEFORE[]         = ".uno:About";
@@ -803,7 +803,7 @@ void MenuBarManager::CheckAndAddMenuExtension( Menu* pMenu )
     }
 }
 
-static void lcl_CheckForChildren(Menu* pMenu, sal_uInt16 nItemId)
+static void lcl_CheckForChildren(AbstractMenu* pMenu, sal_uInt16 nItemId)
 {
     if (PopupMenu* pThisPopup = pMenu->GetPopupMenu( nItemId ))
         pMenu->EnableItem( nItemId, pThisPopup->GetItemCount() ? true : false );
@@ -813,7 +813,7 @@ static void lcl_CheckForChildren(Menu* pMenu, sal_uInt16 nItemId)
 // vcl handler
 //_________________________________________________________________________________________________________________
 
-IMPL_LINK( MenuBarManager, Activate, Menu *, pMenu )
+IMPL_LINK( MenuBarManager, Activate, AbstractMenu *, pMenu )
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::Activate" );
     if ( pMenu == m_pVCLMenu )
@@ -863,8 +863,9 @@ IMPL_LINK( MenuBarManager, Activate, Menu *, pMenu )
                 ( pMenu->GetItemText( nItemId ).Len() == 0 ))
             {
                 String aCommand = pMenu->GetItemCommand( nItemId );
-                if ( aCommand.Len() > 0 )
+                if ( aCommand.Len() > 0 ) {
                     pMenu->SetItemText( nItemId, RetrieveLabelFromCommand( aCommand ));
+                }
             }
         }
 
@@ -1004,11 +1005,14 @@ IMPL_LINK( MenuBarManager, Activate, Menu *, pMenu )
         }
     }
 
+    // Freeze the menu
+//    m_pVCLMenu->Freeze();
+
     return 1;
 }
 
 
-IMPL_LINK( MenuBarManager, Deactivate, Menu *, pMenu )
+IMPL_LINK( MenuBarManager, Deactivate, AbstractMenu *, pMenu )
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::Deactivate" );
     if ( pMenu == m_pVCLMenu )
@@ -1044,7 +1048,7 @@ IMPL_LINK( MenuBarManager, AsyncSettingsHdl, Timer*,)
     return 0;
 }
 
-IMPL_LINK( MenuBarManager, Select, Menu *, pMenu )
+IMPL_LINK( MenuBarManager, Select, AbstractMenu *, pMenu )
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::Select" );
     URL                     aTargetURL;
@@ -1219,7 +1223,7 @@ sal_Bool MenuBarManager::CreatePopupMenuController( MenuItemHandler* pMenuItemHa
     return sal_False;
 }
 
-void MenuBarManager::FillMenuManager( Menu* pMenu, const Reference< XFrame >& rFrame, const Reference< XDispatchProvider >& rDispatchProvider, const rtl::OUString& rModuleIdentifier, sal_Bool bDelete, sal_Bool bDeleteChildren )
+void MenuBarManager::FillMenuManager( AbstractMenu* pMenu, const Reference< XFrame >& rFrame, const Reference< XDispatchProvider >& rDispatchProvider, const rtl::OUString& rModuleIdentifier, sal_Bool bDelete, sal_Bool bDeleteChildren )
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::FillMenuManager" );
     m_xFrame            = rFrame;
@@ -1664,8 +1668,8 @@ void MenuBarManager::RetrieveImageManagers()
 }
 
 void MenuBarManager::FillMenuWithConfiguration(
-    sal_uInt16&                             nId,
-    Menu*                               pMenu,
+    sal_uInt16&                         nId,
+    AbstractMenu*                       pMenu,
     const ::rtl::OUString&              rModuleIdentifier,
     const Reference< XIndexAccess >&    rItemContainer,
     const Reference< XURLTransformer >& rTransformer )
@@ -1675,7 +1679,7 @@ void MenuBarManager::FillMenuWithConfiguration(
     MenuBarManager::FillMenu( nId, pMenu, rModuleIdentifier, rItemContainer, xEmptyDispatchProvider );
 
     // Merge add-on menu entries into the menu bar
-    MenuBarManager::MergeAddonMenus( static_cast< Menu* >( pMenu ),
+    MenuBarManager::MergeAddonMenus( static_cast< AbstractMenu* >( pMenu ),
                                      AddonsOptions().GetMergeMenuInstructions(),
                                      rModuleIdentifier );
 
@@ -1700,15 +1704,15 @@ void MenuBarManager::FillMenuWithConfiguration(
 }
 
 void MenuBarManager::FillMenu(
-    sal_uInt16&                               nId,
-    Menu*                                 pMenu,
+    sal_uInt16&                           nId,
+    AbstractMenu*                         pMenu,
     const rtl::OUString&                  rModuleIdentifier,
     const Reference< XIndexAccess >&      rItemContainer,
     const Reference< XDispatchProvider >& rDispatchProvider )
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::FillMenu" );
     // Fill menu bar with container contents
-    for ( sal_Int32 n = 0; n < rItemContainer->getCount(); n++ )
+     for ( sal_Int32 n = 0; n < rItemContainer->getCount(); n++ )
     {
         Sequence< PropertyValue >       aProp;
         rtl::OUString                   aCommandURL;
@@ -1811,7 +1815,7 @@ void MenuBarManager::FillMenu(
 }
 
 void MenuBarManager::MergeAddonMenus(
-    Menu* pMenuBar,
+    AbstractMenu* pMenuBar,
     const MergeMenuInstructionContainer& aMergeInstructionContainer,
     const ::rtl::OUString& rModuleIdentifier )
 {
@@ -1836,7 +1840,7 @@ void MenuBarManager::MergeAddonMenus(
             MenuBarMerger::GetSubMenu( rMergeInstruction.aMergeMenu, aMergeMenuItems );
 
             // try to find the reference point for our merge operation
-            Menu* pMenu = pMenuBar;
+            AbstractMenu* pMenu = pMenuBar;
             ReferencePathInfo aResult = MenuBarMerger::FindReferencePath( aMergePath, pMenu );
 
             if ( aResult.eResult == RP_OK )
@@ -1916,7 +1920,7 @@ void MenuBarManager::SetItemContainer( const Reference< XIndexAccess >& rItemCon
         sal_uInt16          nId = 1;
 
         // Fill menu bar with container contents
-        FillMenuWithConfiguration( nId, (Menu *)m_pVCLMenu, m_aModuleIdentifier, rItemContainer, m_xURLTransformer );
+        FillMenuWithConfiguration( nId, (AbstractMenu *)m_pVCLMenu, m_aModuleIdentifier, rItemContainer, m_xURLTransformer );
 
         // Refill menu manager again
         Reference< XDispatchProvider > xDispatchProvider;
@@ -1996,7 +2000,7 @@ void MenuBarManager::AddMenu(MenuBarManager* pSubMenuManager,const ::rtl::OUStri
     m_aMenuItemHandlerVector.push_back( pMenuItemHandler );
 }
 
-sal_uInt16 MenuBarManager::FillItemCommand(::rtl::OUString& _rItemCommand,Menu* _pMenu,sal_uInt16 _nIndex) const
+sal_uInt16 MenuBarManager::FillItemCommand(::rtl::OUString& _rItemCommand, AbstractMenu* _pMenu,sal_uInt16 _nIndex) const
 {
     RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, "framework", "Ocke.Janssen@sun.com", "MenuBarManager::FillItemCommand" );
     sal_uInt16 nItemId = _pMenu->GetItemId( _nIndex );
diff --git a/framework/source/uielement/menubarmerger.cxx b/framework/source/uielement/menubarmerger.cxx
index 544c52a..213ad89 100644
--- a/framework/source/uielement/menubarmerger.cxx
+++ b/framework/source/uielement/menubarmerger.cxx
@@ -96,7 +96,7 @@ void MenuBarMerger::RetrieveReferencePath(
 
 ReferencePathInfo MenuBarMerger::FindReferencePath(
     const ::std::vector< ::rtl::OUString >& rReferencePath,
-    Menu* pMenu )
+    AbstractMenu* pMenu )
 {
     sal_uInt32       i( 0 );
     const sal_uInt32 nCount( rReferencePath.size() );
@@ -108,7 +108,7 @@ ReferencePathInfo MenuBarMerger::FindReferencePath(
         return aResult;
     }
 
-    Menu*            pCurrMenu( pMenu );
+    AbstractMenu*            pCurrMenu( pMenu );
     RPResultInfo     eResult( RP_OK );
 
     sal_Int32  nLevel( - 1 );
@@ -157,7 +157,7 @@ ReferencePathInfo MenuBarMerger::FindReferencePath(
     return aResult;
 }
 
-sal_uInt16 MenuBarMerger::FindMenuItem( const ::rtl::OUString& rCmd, Menu* pCurrMenu )
+sal_uInt16 MenuBarMerger::FindMenuItem( const ::rtl::OUString& rCmd, AbstractMenu* pCurrMenu )
 {
     for ( sal_uInt16 i = 0; i < pCurrMenu->GetItemCount(); i++ )
     {
@@ -173,7 +173,7 @@ sal_uInt16 MenuBarMerger::FindMenuItem( const ::rtl::OUString& rCmd, Menu* pCurr
 }
 
 bool MenuBarMerger::CreateSubMenu(
-    Menu*                     pSubMenu,
+    AbstractMenu*             pSubMenu,
     sal_uInt16&               nItemId,
     const ::rtl::OUString&    rModuleIdentifier,
     const AddonMenuContainer& rAddonSubMenu )
@@ -211,7 +211,7 @@ bool MenuBarMerger::CreateSubMenu(
 }
 
 bool MenuBarMerger::MergeMenuItems(
-    Menu*                     pMenu,
+    AbstractMenu*             pMenu,
     sal_uInt16                nPos,
     sal_uInt16                nModIndex,
     sal_uInt16&               nItemId,
@@ -253,7 +253,7 @@ bool MenuBarMerger::MergeMenuItems(
 }
 
 bool MenuBarMerger::ReplaceMenuItem(
-    Menu*                     pMenu,
+    AbstractMenu*             pMenu,
     sal_uInt16                nPos,
     sal_uInt16&               rItemId,
     const ::rtl::OUString&    rModuleIdentifier,
@@ -267,7 +267,7 @@ bool MenuBarMerger::ReplaceMenuItem(
 }
 
 bool MenuBarMerger::RemoveMenuItems(
-    Menu*                     pMenu,
+    AbstractMenu*             pMenu,
     sal_uInt16                nPos,
     const ::rtl::OUString&    rMergeCommandParameter )
 {
@@ -287,7 +287,7 @@ bool MenuBarMerger::RemoveMenuItems(
 }
 
 bool MenuBarMerger::ProcessMergeOperation(
-    Menu*                     pMenu,
+    AbstractMenu*             pMenu,
     sal_uInt16                nPos,
     sal_uInt16&               nItemId,
     const ::rtl::OUString&    rMergeCommand,
@@ -336,7 +336,7 @@ bool MenuBarMerger::ProcessFallbackOperation(
     }
     else if ( rMergeFallback.equalsAsciiL( MERGEFALLBACK_ADDPATH, MERGEFALLBACK_ADDPATH_LEN ))
     {
-        Menu*            pCurrMenu( aRefPathInfo.pPopupMenu );
+        AbstractMenu*    pCurrMenu( aRefPathInfo.pPopupMenu );
         sal_Int32        nLevel( aRefPathInfo.nLevel );
         const sal_Int32  nSize( rReferencePath.size() );
         bool             bFirstLevel( true );
diff --git a/framework/source/uielement/menubarwrapper.cxx b/framework/source/uielement/menubarwrapper.cxx
index 45d5bf8..f819b5a 100644
--- a/framework/source/uielement/menubarwrapper.cxx
+++ b/framework/source/uielement/menubarwrapper.cxx
@@ -130,6 +130,19 @@ void SAL_CALL MenuBarWrapper::dispose() throw (::com::sun::star::uno::RuntimeExc
     m_bDisposed = sal_True;
 }
 
+//void generateFullMenuBar( MenuBarManager *pMenuBarManager, MenuBar *pMenuBar )
+//{
+//    for (int i=0; i < pMenuBar->GetItemCount(); i++)
+//    {
+//        sal_Int16 nId = pMenuBar->GetItemId( i );
+
+//        String aCommandLabel = pMenuBar->GetItemCommand( nId );
+
+//        String label = pMenuBarManager->RetrieveLabelFromCommand( aCommandLabel );
+//        pMenuBar->SetItemText( nId, label );
+//    }
+//}
+
 // XInitialization
 void SAL_CALL MenuBarWrapper::initialize( const Sequence< Any >& aArguments ) throw ( Exception, RuntimeException )
 {
@@ -216,6 +229,9 @@ void SAL_CALL MenuBarWrapper::initialize( const Sequence< Any >& aArguments ) th
                                                                       sal_True );
 
                 m_xMenuBarManager = Reference< XComponent >( static_cast< OWeakObject *>( pMenuBarManager ), UNO_QUERY );
+
+//                pMenuBarManager->GenerateFullMenuHierarchy( pVCLMenuBar );
+                pVCLMenuBar->Freeze();
             }
 
             // Initialize toolkit menu bar implementation to have awt::XMenuBar for data exchange.
diff --git a/vcl/Library_vcl.mk b/vcl/Library_vcl.mk
index 53f9d4a..56d2bf3 100644
--- a/vcl/Library_vcl.mk
+++ b/vcl/Library_vcl.mk
@@ -95,6 +95,7 @@ $(eval $(call gb_Library_use_externals,vcl,\
 	icule \
 	icuuc \
 	lcms2 \
+	gio \
 ))
 
 $(eval $(call gb_Library_add_cobjects,vcl,\
diff --git a/vcl/Library_vclplug_gtk.mk b/vcl/Library_vclplug_gtk.mk
index e816fcf..c4cce2a 100644
--- a/vcl/Library_vclplug_gtk.mk
+++ b/vcl/Library_vclplug_gtk.mk
@@ -99,10 +99,13 @@ $(eval $(call gb_Library_add_exception_objects,vclplug_gtk,\
     vcl/unx/gtk/gdi/salnativewidgets-gtk \
     vcl/unx/gtk/window/gtkframe \
     vcl/unx/gtk/window/gtkobject \
-	vcl/unx/gtk/fpicker/resourceprovider \
-	vcl/unx/gtk/fpicker/SalGtkPicker \
-	vcl/unx/gtk/fpicker/SalGtkFilePicker \
-	vcl/unx/gtk/fpicker/SalGtkFolderPicker \
+    vcl/unx/gtk/window/gloactiongroup \
+    vcl/unx/gtk/window/gtksalmenu \
+    vcl/unx/gtk/window/glomenu \
+    vcl/unx/gtk/fpicker/resourceprovider \
+    vcl/unx/gtk/fpicker/SalGtkPicker \
+    vcl/unx/gtk/fpicker/SalGtkFilePicker \
+    vcl/unx/gtk/fpicker/SalGtkFolderPicker \
 ))
 
 ifeq ($(ENABLE_GTK_PRINT),TRUE)
diff --git a/vcl/Library_vclplug_gtk3.mk b/vcl/Library_vclplug_gtk3.mk
index 120199c..fd66689 100644
--- a/vcl/Library_vclplug_gtk3.mk
+++ b/vcl/Library_vclplug_gtk3.mk
@@ -110,6 +110,9 @@ $(eval $(call gb_Library_add_exception_objects,vclplug_gtk3,\
     vcl/unx/gtk3/gdi/gtk3salprn-gtk \
     vcl/unx/gtk3/window/gtk3gtkframe \
     vcl/unx/gtk3/window/gtk3gtkobject \
+	vcl/unx/gtk3/window/gtk3gtksalmenu \
+	vcl/unx/gtk3/window/gtk3glomenu \
+	vcl/unx/gtk3/window/gtk3gloactiongroup \
 ))
 
 $(eval $(call gb_Library_use_static_libraries,vclplug_gtk3,\
diff --git a/vcl/inc/salmenu.hxx b/vcl/inc/salmenu.hxx
index 1d14a7e..2f8d680 100644
--- a/vcl/inc/salmenu.hxx
+++ b/vcl/inc/salmenu.hxx
@@ -41,7 +41,7 @@ class SalFrame;
 
 struct SalItemParams
 {
-    sal_uInt16          nId;                    // item Id
+    sal_uInt16      nId;                    // item Id
     MenuItemType    eType;                  // MenuItem-Type
     MenuItemBits    nBits;                  // MenuItem-Bits
     Menu*           pMenu;                  // Pointer to Menu
@@ -52,7 +52,7 @@ struct SalItemParams
 
 struct SalMenuButtonItem
 {
-    sal_uInt16              mnId;
+    sal_uInt16          mnId;
     Image               maImage;
     rtl::OUString       maToolTipText;
 
@@ -91,6 +91,9 @@ public:
     virtual bool AddMenuBarButton( const SalMenuButtonItem& ); // return false if not implemented or failure
     virtual void RemoveMenuBarButton( sal_uInt16 nId );
 
+    virtual void SetItemCommand( unsigned nPos, SalMenuItem* pSalMenuItem, const rtl::OUString& aCommandStr ) {}
+    virtual void Freeze() {}
+
     // return an empty rectangle if not implemented
     // return Rectangle( Point( -1, -1 ), Size( 1, 1 ) ) if menu bar buttons implemented
     // but rectangle cannot be determined
diff --git a/vcl/inc/unx/gtk/gloactiongroup.h b/vcl/inc/unx/gtk/gloactiongroup.h
new file mode 100644
index 0000000..4392e18
--- /dev/null
+++ b/vcl/inc/unx/gtk/gloactiongroup.h
@@ -0,0 +1,99 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/*
+ * Copyright © 2011 Canonical Ltd.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Author: Antonio Fernández <antonio.fernandez@aentos.es>
+ */
+
+#ifndef GLOACTIONGROUP_H
+#define GLOACTIONGROUP_H
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_LO_ACTION_GROUP                          (g_lo_action_group_get_type ())
+#define G_LO_ACTION_GROUP(inst)                         (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
+                                                         G_TYPE_LO_ACTION_GROUP, GLOActionGroup))
+#define G_LO_ACTION_GROUP_CLASS(klass)                  (G_TYPE_CHECK_CLASS_CAST ((klass),                       \
+                                                         G_TYPE_LO_ACTION_GROUP, GLOActionGroupClass))
+#define G_IS_LO_ACTION_GROUP(inst)                      (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
+                                                         G_TYPE_LO_ACTION_GROUP))
+#define G_IS_LO_ACTION_GROUP_CLASS(klass)               (G_TYPE_CHECK_CLASS_TYPE ((klass),                       \
+                                                         G_TYPE_LO_ACTION_GROUP))
+#define G_LO_ACTION_GROUP_GET_CLASS(inst)               (G_TYPE_INSTANCE_GET_CLASS ((inst),                      \
+                                                         G_TYPE_LO_ACTION_GROUP, GLOActionGroupClass))
+
+typedef struct _GLOActionGroupPrivate                   GLOActionGroupPrivate;
+typedef struct _GLOActionGroupClass                     GLOActionGroupClass;
+typedef struct _GLOActionGroup                          GLOActionGroup;
+
+struct _GLOActionGroup
+{
+    /*< private >*/
+    GObject parent_instance;
+
+    GLOActionGroupPrivate *priv;
+};
+
+struct _GLOActionGroupClass
+{
+    /*< private >*/
+    GObjectClass parent_class;
+
+    /*< private >*/
+    gpointer padding[12];
+};
+
+GType               g_lo_action_group_get_type              (void) G_GNUC_CONST;
+
+GLOActionGroup *    g_lo_action_group_new                   (void);
+
+void                g_lo_action_group_insert                (GLOActionGroup *group,
+                                                             const gchar    *action_name,
+                                                             gpointer        action_info);
+
+void                g_lo_action_group_insert_stateful       (GLOActionGroup     *group,
+                                                             const gchar        *action_name,
+                                                             gpointer            action_info,
+                                                             const GVariantType *parameter_type,
+                                                             const GVariantType *state_type,
+                                                             GVariant           *state_hint,
+                                                             GVariant           *state);
+
+void                g_lo_action_group_set_action_enabled    (GLOActionGroup *group,
+                                                             const gchar    *action_name,
+                                                             gboolean        enabled);
+
+gpointer            g_lo_action_group_get_action_item       (GLOActionGroup *group,
+                                                             const gchar    *action_name);
+
+void                g_lo_action_group_remove                (GLOActionGroup *group,
+                                                             const gchar    *action_name);
+
+void                g_lo_action_group_clear                 (GLOActionGroup *group);
+
+void                g_lo_action_group_merge                 (GLOActionGroup *input_group,
+                                                             GLOActionGroup *output_group);
+
+G_END_DECLS
+
+#endif // GLOACTIONGROUP_H
+
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/inc/unx/gtk/glomenu.h b/vcl/inc/unx/gtk/glomenu.h
new file mode 100644
index 0000000..21c048f
--- /dev/null
+++ b/vcl/inc/unx/gtk/glomenu.h
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/*
+ * Copyright © 2011 Canonical Ltd.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Author: Antonio Fernández <antonio.fernandez@aentos.es>
+ */
+
+#ifndef __G_LO_MENU_H__
+#define __G_LO_MENU_H__
+
+#include <gio/gio.h>
+
+#define G_LO_MENU_ATTRIBUTE_ACCELERATOR     "accel"
+
+G_BEGIN_DECLS
+
+#define G_TYPE_LO_MENU          (g_lo_menu_get_type ())
+#define G_LO_MENU(inst)         (G_TYPE_CHECK_INSTANCE_CAST ((inst), \
+                                 G_TYPE_LO_MENU, GLOMenu))
+#define G_IS_LO_MENU(inst)      (G_TYPE_CHECK_INSTANCE_TYPE ((inst), \
+                                 G_TYPE_LO_MENU))
+
+typedef struct _GLOMenu GLOMenu;
+
+class GtkSalMenuItem;
+
+GLIB_AVAILABLE_IN_2_32
+GType       g_lo_menu_get_type                                          (void) G_GNUC_CONST;
+GLIB_AVAILABLE_IN_2_32
+GLOMenu *   g_lo_menu_new                                               (void);
+
+void        g_lo_menu_insert                                            (GLOMenu     *menu,
+                                                                         gint         position,
+                                                                         const char  *label);
+
+void        g_lo_menu_insert_in_section                                 (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position,
+                                                                         const gchar *label);
+
+void        g_lo_menu_new_section                                       (GLOMenu     *menu,
+                                                                         gint         position,
+                                                                         const gchar *label);
+
+void        g_lo_menu_insert_section                                    (GLOMenu     *menu,
+                                                                         gint         position,
+                                                                         const gchar *label,
+                                                                         GMenuModel  *section);
+
+GLOMenu *   g_lo_menu_get_section                                       (GLOMenu     *menu,
+                                                                         gint         section);
+
+void        g_lo_menu_remove                                            (GLOMenu     *menu,
+                                                                         gint         position);
+
+void        g_lo_menu_remove_from_section                               (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position);
+
+void        g_lo_menu_set_label                                         (GLOMenu     *menu,
+                                                                         gint         position,
+                                                                         const gchar *label);
+
+void        g_lo_menu_set_label_to_item_in_section                      (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position,
+                                                                         const gchar *label);
+
+gchar *     g_lo_menu_get_label_from_item_in_section                    (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position);
+
+void        g_lo_menu_set_action_and_target_value                       (GLOMenu     *menu,
+                                                                         gint         position,
+                                                                         const gchar *command,
+                                                                         GVariant    *target_value);
+
+void        g_lo_menu_set_action_and_target_value_to_item_in_section    (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position,
+                                                                         const gchar *command,
+                                                                         GVariant    *target_value);
+
+void        g_lo_menu_set_accelerator_to_item_in_section                (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position,
+                                                                         const gchar *accelerator);
+
+void        g_lo_menu_set_submenu_to_item_in_section                    (GLOMenu     *menu,
+                                                                         gint         section,
+                                                                         gint         position,
+                                                                         GMenuModel  *submenu);
+
+G_END_DECLS
+
+#endif /* __G_LO_MENU_H__ */
+
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/inc/unx/gtk/gtkinst.hxx b/vcl/inc/unx/gtk/gtkinst.hxx
index 89743ca..5ec226e 100644
--- a/vcl/inc/unx/gtk/gtkinst.hxx
+++ b/vcl/inc/unx/gtk/gtkinst.hxx
@@ -113,6 +113,10 @@ public:
     virtual SalSystem*          CreateSalSystem();
     virtual SalInfoPrinter*     CreateInfoPrinter(SalPrinterQueueInfo* pPrinterQueueInfo, ImplJobSetup* pJobSetup);
     virtual SalPrinter*         CreatePrinter( SalInfoPrinter* pInfoPrinter );
+    virtual SalMenu*            CreateMenu( sal_Bool, Menu* );
+    virtual void                DestroyMenu( SalMenu* pMenu );
+    virtual SalMenuItem*        CreateMenuItem( const SalItemParams* );
+    virtual void                DestroyMenuItem( SalMenuItem* pItem );
     virtual SalTimer*           CreateSalTimer();
     virtual void                AddToRecentDocumentList(const rtl::OUString& rFileUrl, const rtl::OUString& rMimeType);
     virtual SalVirtualDevice*   CreateVirtualDevice( SalGraphics*,
diff --git a/vcl/inc/unx/gtk/gtksalmenu.hxx b/vcl/inc/unx/gtk/gtksalmenu.hxx
new file mode 100644
index 0000000..324b430
--- /dev/null
+++ b/vcl/inc/unx/gtk/gtksalmenu.hxx
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/*
+ * Copyright © 2011 Canonical Ltd.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Author: Antonio Fernández <antonio.fernandez@aentos.es>
+ */
+
+#ifndef GTKSALMENU_HXX
+#define GTKSALMENU_HXX
+
+#include <vcl/sv.h>
+#include <vcl/bitmap.hxx>
+#include <unx/gtk/gtkframe.hxx>
+#include <unx/salmenu.h>
+
+#include <gio/gio.h>
+
+#include "glomenu.h"
+#include "gloactiongroup.h"
+
+
+class MenuItemList;
+class GtkSalMenuItem;
+
+class GtkSalMenu : public SalMenu
+{
+private:
+    std::vector< GtkSalMenuItem* >  maItems;
+
+    sal_Bool                        mbMenuBar;
+    Menu*                           mpVCLMenu;
+    GtkSalMenu*                     mpParentSalMenu;
+    const GtkSalFrame*              mpFrame;
+
+    // GMenuModel and GActionGroup attributes
+    GMenuModel*                     mpMenuModel;
+    GActionGroup*                   mpActionGroup;
+
+    void            GetItemSectionAndPosition( unsigned nPos, unsigned *insertSection, unsigned *insertPos );
+
+public:
+    GtkSalMenu( sal_Bool bMenuBar );
+    virtual ~GtkSalMenu();
+
+    virtual sal_Bool            VisibleMenuBar();   // must return TRUE to actually DISPLAY native menu bars
+                                                    // otherwise only menu messages are processed (eg, OLE on Windows)
+
+    virtual void                InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos );
+    virtual void                RemoveItem( unsigned nPos );
+    virtual void                SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos );
+    virtual void                SetFrame( const SalFrame* pFrame );
+    virtual const GtkSalFrame*  GetFrame() const;
+    virtual void                CheckItem( unsigned nPos, sal_Bool bCheck );
+    virtual void                EnableItem( unsigned nPos, sal_Bool bEnable );
+    virtual void                SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const rtl::OUString& rText );
+    virtual void                SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage);
+    virtual void                SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const rtl::OUString& rKeyName );
+    virtual void                GetSystemMenuData( SystemMenuData* pData );
+    virtual void                SetItemCommand( unsigned nPos, SalMenuItem* pSalMenuItem, const rtl::OUString& aCommandStr );
+    virtual void                Freeze();
+
+    virtual void                SetMenu( Menu* pMenu ) { mpVCLMenu = pMenu; }
+    virtual Menu*               GetMenu() { return mpVCLMenu; }
+    virtual GtkSalMenu*         GetParentSalMenu() { return mpParentSalMenu; }
+    virtual GMenuModel*         GetMenuModel() { return mpMenuModel; }
+    virtual unsigned            GetItemCount() { return maItems.size(); }
+    virtual GtkSalMenuItem*     GetItemAtPos( unsigned nPos ) { return maItems[ nPos ]; }
+    virtual GActionGroup*       GetActionGroup() { return mpActionGroup; }
+};
+
+class GtkSalMenuItem : public SalMenuItem
+{
+public:
+    GtkSalMenuItem( const SalItemParams* );
+    virtual ~GtkSalMenuItem();
+
+    sal_uInt16          mnId;               // Item ID
+    MenuItemBits        mnBits;             // Item bits
+    MenuItemType        mnType;             // Item type
+    Menu*               mpVCLMenu;          // VCL Menu into which this MenuItem is inserted
+    GtkSalMenu*         mpParentMenu;       // The menu in which this menu item is inserted
+    GtkSalMenu*         mpSubMenu;          // Sub menu of this item (if defined)
+
+    // FIXME: Most of this info should be retrieved from the GMenuModel, but doing that crashes the application at the moment.
+    gchar*              maCommand;          // Item command
+    gchar*              maLabel;            // Item label
+    gchar*              maAccel;            // Item accelerator
+};
+
+#endif // GTKSALMENU_HXX
+
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/inc/unx/salmenu.h b/vcl/inc/unx/salmenu.h
index f693a33..f9a89f7 100644
--- a/vcl/inc/unx/salmenu.h
+++ b/vcl/inc/unx/salmenu.h
@@ -31,7 +31,7 @@
 
 #include <vcl/sv.h>
 #include <vcl/bitmap.hxx>
-#include <vcl/salmenu.hxx>
+#include <salmenu.hxx>
 
 
 class X11SalMenu : public SalMenu
@@ -40,15 +40,15 @@ public:
     X11SalMenu() {}
     virtual ~X11SalMenu();
 
-    virtual BOOL VisibleMenuBar();  // must return TRUE to actually DISPLAY native menu bars
+    virtual sal_Bool VisibleMenuBar();  // must return TRUE to actually DISPLAY native menu bars
                             // otherwise only menu messages are processed (eg, OLE on Windows)
 
     virtual void InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos );
     virtual void RemoveItem( unsigned nPos );
     virtual void SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos );
     virtual void SetFrame( const SalFrame* pFrame );
-    virtual void CheckItem( unsigned nPos, BOOL bCheck );
-    virtual void EnableItem( unsigned nPos, BOOL bEnable );
+    virtual void CheckItem( unsigned nPos, sal_Bool bCheck );
+    virtual void EnableItem( unsigned nPos, sal_Bool bEnable );
     virtual void SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const rtl::OUString& rText );
     virtual void SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage);
     virtual void SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const rtl::OUString& rKeyName );
diff --git a/vcl/inc/vcl/menu.hxx b/vcl/inc/vcl/menu.hxx
index c9388ee..7538faf 100644
--- a/vcl/inc/vcl/menu.hxx
+++ b/vcl/inc/vcl/menu.hxx
@@ -112,6 +112,96 @@ struct ImplMenuDelData
     bool isDeleted() const { return mpMenu == 0; }
 };
 
+// ----------------
+// - AbstractMenu -
+// ----------------
+
+class VCL_DLLPUBLIC AbstractMenu : public Resource
+{
+public:
+    virtual ~AbstractMenu() {}
+
+    virtual SAL_DLLPRIVATE Window*  ImplGetWindow() const = 0;
+
+    virtual void                    InsertItem( sal_uInt16 nItemId, const XubString& rStr,
+                                                MenuItemBits nItemBits = 0,
+                                                sal_uInt16 nPos = MENU_APPEND ) = 0;
+    virtual void                    InsertItem( sal_uInt16 nItemId,
+                                                const XubString& rString, const Image& rImage,
+                                                MenuItemBits nItemBits = 0,
+                                                sal_uInt16 nPos = MENU_APPEND ) = 0;
+    virtual void                    InsertSeparator( sal_uInt16 nPos = MENU_APPEND ) = 0;
+    virtual void                    RemoveItem( sal_uInt16 nPos ) = 0;
+    virtual void                    CopyItem( const Menu& rMenu, sal_uInt16 nPos,
+                                              sal_uInt16 nNewPos = MENU_APPEND ) = 0;
+    virtual void                    Clear() = 0;
+
+    virtual void                    SetMenuFlags( sal_uInt16 nFlags ) = 0;
+    virtual sal_uInt16              GetMenuFlags() const = 0;
+
+    virtual sal_uInt16              GetItemCount() const = 0;
+    virtual sal_uInt16              GetItemId( sal_uInt16 nPos ) const = 0;
+    virtual sal_uInt16              GetItemPos( sal_uInt16 nItemId ) const = 0;
+    virtual MenuItemType            GetItemType( sal_uInt16 nPos ) const = 0;
+    virtual sal_uInt16              GetCurItemId() const = 0;
+
+    virtual void                    SetItemBits( sal_uInt16 nItemId, MenuItemBits nBits ) = 0;
+    virtual MenuItemBits            GetItemBits( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetUserValue( sal_uInt16 nItemId, sal_uLong nValue ) = 0;
+    virtual sal_uLong               GetUserValue( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetPopupMenu( sal_uInt16 nItemId, PopupMenu* pMenu ) = 0;
+    virtual PopupMenu*              GetPopupMenu( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetAccelKey( sal_uInt16 nItemId, const KeyCode& rKeyCode ) = 0;
+
+    virtual void                    CheckItem( sal_uInt16 nItemId, sal_Bool bCheck = sal_True ) = 0;
+    virtual sal_Bool                IsItemChecked( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    EnableItem( sal_uInt16 nItemId, sal_Bool bEnable = sal_True ) = 0;
+    virtual sal_Bool                IsItemEnabled( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    ShowItem( sal_uInt16 nItemId, sal_Bool bVisible = sal_True ) = 0;
+    virtual void                    HideItem( sal_uInt16 nItemId ) = 0;
+
+    virtual sal_Bool                IsMenuBar() const = 0;
+
+    virtual void                    RemoveDisabledEntries( sal_Bool bCheckPopups = sal_True,
+                                                           sal_Bool bRemoveEmptyPopups = sal_False ) = 0;
+
+    virtual void                    SetItemText( sal_uInt16 nItemId, const XubString& rStr ) = 0;
+    virtual XubString               GetItemText( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetItemImage( sal_uInt16 nItemId, const Image& rImage ) = 0;
+    virtual Image                   GetItemImage( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetItemCommand( sal_uInt16 nItemId, const XubString& rCommand ) = 0;
+    virtual const XubString&        GetItemCommand( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetTipHelpText( sal_uInt16 nItemId, const XubString& rString ) = 0;
+
+    virtual void                    SetHelpCommand( sal_uInt16 nItemId, const XubString& rString ) = 0;
+    virtual const XubString&        GetHelpCommand( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetHelpId( sal_uInt16 nItemId, const rtl::OString& rHelpId ) = 0;
+    virtual rtl::OString            GetHelpId( sal_uInt16 nItemId ) const = 0;
+
+    virtual void                    SetActivateHdl( const Link& rLink ) = 0;
+
+    virtual void                    SetDeactivateHdl( const Link& rLink ) = 0;
+
+    virtual void                    SetHighlightHdl( const Link& rLink ) = 0;
+
+    virtual void                    SetSelectHdl( const Link& rLink ) = 0;
+
+    // Returns the system's menu handle if native menus are supported
+    // pData must point to a SystemMenuData structure
+    virtual sal_Bool                GetSystemMenuData( SystemMenuData* pData ) const = 0;
+
+    virtual void                    Freeze(void) = 0;
+};
+
 // --------
 // - Menu -
 // --------
@@ -123,7 +213,7 @@ struct MenuLogo
     Color       aEndColor;
 };
 
-class VCL_DLLPUBLIC Menu : public Resource
+class VCL_DLLPUBLIC Menu : public AbstractMenu
 {
     friend class MenuBar;
     friend class MenuBarWindow;
@@ -158,7 +248,7 @@ private:
     sal_uInt16              nImgOrChkPos;
     sal_uInt16              nTextPos;
 
-    sal_Bool                bIsMenuBar  : 1,        // Handelt es sich um den MenuBar
+    sal_Bool            bIsMenuBar  : 1,        // Handelt es sich um den MenuBar
                         bCanceled   : 1,        // Waehrend eines Callbacks abgebrochen
                         bInCallback : 1,        // In Activate/Deactivate
                         bKilled     : 1;        // Gekillt...
@@ -208,11 +298,13 @@ public:
                             Menu();
                             Menu( sal_Bool bMenuBar );
     SAL_DLLPRIVATE Window*  ImplGetWindow() const { return pWindow; }
-#if defined(QUARTZ)
-    // ImplSelectWithStart() is used in vcl/aqua/source/window/salnsmenu.mm
-    SAL_DLLPRIVATE void ImplSelectWithStart( Menu* pStartMenu = NULL );
-#endif
-public:
+//#if defined(QUARTZ)
+//    // ImplSelectWithStart() is used in vcl/aqua/source/window/salnsmenu.mm
+//    SAL_DLLPRIVATE void ImplSelectWithStart( Menu* pStartMenu = NULL );
+//#endif
+    void ImplSelectWithStart( Menu* pStartMenu = NULL );
+
+    public:
     virtual             ~Menu();
 
     virtual void        Activate();
@@ -276,12 +368,12 @@ public:
     void                ShowItem( sal_uInt16 nItemId, sal_Bool bVisible = sal_True );
     void                HideItem( sal_uInt16 nItemId ) { ShowItem( nItemId, sal_False ); }
 
-    sal_Bool                IsItemPosVisible( sal_uInt16 nItemPos ) const;
-    sal_Bool                IsMenuVisible() const;
-    sal_Bool                IsMenuBar() const { return bIsMenuBar; }
+    sal_Bool            IsItemPosVisible( sal_uInt16 nItemPos ) const;
+    sal_Bool            IsMenuVisible() const;
+    sal_Bool            IsMenuBar() const { return bIsMenuBar; }
 
     void                RemoveDisabledEntries( sal_Bool bCheckPopups = sal_True, sal_Bool bRemoveEmptyPopups = sal_False );
-    sal_Bool                HasValidEntries( sal_Bool bCheckPopups = sal_True );
+    sal_Bool            HasValidEntries( sal_Bool bCheckPopups = sal_True );
 
     void                SetItemText( sal_uInt16 nItemId, const XubString& rStr );
     XubString           GetItemText( sal_uInt16 nItemId ) const;
@@ -291,7 +383,7 @@ public:
     void                SetItemImageAngle( sal_uInt16 nItemId, long nAngle10 );
     long                GetItemImageAngle( sal_uInt16 nItemId ) const;
     void                SetItemImageMirrorMode( sal_uInt16 nItemId, sal_Bool bMirror );
-    sal_Bool                GetItemImageMirrorMode( sal_uInt16 ) const;
+    sal_Bool            GetItemImageMirrorMode( sal_uInt16 ) const;
 
     void                SetItemCommand( sal_uInt16 nItemId, const XubString& rCommand );
     const XubString&    GetItemCommand( sal_uInt16 nItemId ) const;
@@ -327,8 +419,8 @@ public:
 
     void                AddEventListener( const Link& rEventListener );
     void                RemoveEventListener( const Link& rEventListener );
-    //void                AddChildEventListener( const Link& rEventListener );
-    //void                RemoveChildEventListener( const Link& rEventListener );
+    void                AddChildEventListener( const Link& rEventListener );
+    void                RemoveChildEventListener( const Link& rEventListener );
 
     Menu&               operator =( const Menu& rMenu );
 
@@ -367,6 +459,8 @@ public:
 
     void                HighlightItem( sal_uInt16 nItemPos );
     void                DeHighlight() { HighlightItem( 0xFFFF ); } // MENUITEMPOS_INVALID
+
+    void                Freeze();
 };
 
 // -----------
@@ -378,10 +472,10 @@ class VCL_DLLPUBLIC MenuBar : public Menu
     Link                maCloserHdl;
     Link                maFloatHdl;
     Link                maHideHdl;
-    sal_Bool                mbCloserVisible;
-    sal_Bool                mbFloatBtnVisible;
-    sal_Bool                mbHideBtnVisible;
-    sal_Bool                mbDisplayable;
+    sal_Bool            mbCloserVisible;
+    sal_Bool            mbFloatBtnVisible;
+    sal_Bool            mbHideBtnVisible;
+    sal_Bool            mbDisplayable;
 
     friend class Application;
     friend class Menu;
@@ -391,7 +485,7 @@ class VCL_DLLPUBLIC MenuBar : public Menu
 
     SAL_DLLPRIVATE static Window*   ImplCreate( Window* pParent, Window* pWindow, MenuBar* pMenu );
     SAL_DLLPRIVATE static void      ImplDestroy( MenuBar* pMenu, sal_Bool bDelete );
-    SAL_DLLPRIVATE sal_Bool             ImplHandleKeyEvent( const KeyEvent& rKEvent, sal_Bool bFromMenu = sal_True );
+    SAL_DLLPRIVATE sal_Bool         ImplHandleKeyEvent( const KeyEvent& rKEvent, sal_Bool bFromMenu = sal_True );
 
 public:
                         MenuBar();
@@ -401,17 +495,17 @@ public:
     MenuBar&            operator =( const MenuBar& rMenu );
 
     void                ShowCloser( sal_Bool bShow = sal_True );
-    sal_Bool                HasCloser() const { return mbCloserVisible; }
-    sal_Bool                HasFloatButton() const { return mbFloatBtnVisible; }
-    sal_Bool                HasHideButton() const { return mbHideBtnVisible; }
+    sal_Bool            HasCloser() const { return mbCloserVisible; }
+    sal_Bool            HasFloatButton() const { return mbFloatBtnVisible; }
+    sal_Bool            HasHideButton() const { return mbHideBtnVisible; }
     void                ShowButtons( sal_Bool bClose, sal_Bool bFloat, sal_Bool bHide );
 
     void                SelectEntry( sal_uInt16 nId );
-    sal_Bool                HandleMenuActivateEvent( Menu *pMenu ) const;
-    sal_Bool                HandleMenuDeActivateEvent( Menu *pMenu ) const;
-    sal_Bool                HandleMenuHighlightEvent( Menu *pMenu, sal_uInt16 nEventId ) const;
-    sal_Bool                HandleMenuCommandEvent( Menu *pMenu, sal_uInt16 nEventId ) const;
-    sal_Bool                HandleMenuButtonEvent( Menu *pMenu, sal_uInt16 nEventId ) const;
+    sal_Bool            HandleMenuActivateEvent( Menu *pMenu ) const;
+    sal_Bool            HandleMenuDeActivateEvent( Menu *pMenu ) const;
+    sal_Bool            HandleMenuHighlightEvent( Menu *pMenu, sal_uInt16 nEventId ) const;
+    sal_Bool            HandleMenuCommandEvent( Menu *pMenu, sal_uInt16 nEventId ) const;
+    sal_Bool            HandleMenuButtonEvent( Menu *pMenu, sal_uInt16 nEventId ) const;
 
     void                SetCloserHdl( const Link& rLink )           { maCloserHdl = rLink; }
     const Link&         GetCloserHdl() const                        { return maCloserHdl; }
@@ -425,18 +519,18 @@ public:
     //    and it will be hidden if it was visible before
     //  - note: if a menubar is diplayable, this does not necessarily mean that it is currently visible
     void                SetDisplayable( sal_Bool bDisplayable );
-    sal_Bool                IsDisplayable() const                       { return mbDisplayable; }
+    sal_Bool            IsDisplayable() const                       { return mbDisplayable; }
 
     struct MenuBarButtonCallbackArg
     {
         sal_uInt16      nId;             // Id of the button
-        bool        bHighlight;      // highlight on/off
-        MenuBar*    pMenuBar;        // menubar the button belongs to
+        bool            bHighlight;      // highlight on/off
+        MenuBar*        pMenuBar;        // menubar the button belongs to
     };
     // add an arbitrary button to the menubar (will appear next to closer)
     // passed link will be call with a MenuBarButtonCallbackArg on press
     // passed string will be set as tooltip
-    sal_uInt16              AddMenuBarButton( const Image&, const Link&, const String&, sal_uInt16 nPos = 0 );
+    sal_uInt16          AddMenuBarButton( const Image&, const Link&, const String&, sal_uInt16 nPos = 0 );
     // set the highlight link for additional button with ID nId
     // highlight link will be called with a MenuBarButtonHighlightArg
     // the bHighlight member of that struct shall contain the new state
diff --git a/vcl/source/window/menu.cxx b/vcl/source/window/menu.cxx
index 3b4ac0d..e921805 100644
--- a/vcl/source/window/menu.cxx
+++ b/vcl/source/window/menu.cxx
@@ -1146,7 +1146,8 @@ void Menu::Select()
     }
 }
 
-#if defined(QUARTZ)
+// FIXME: Workaround to make GLOMenu without defining macros.
+//#if defined(QUARTZ)
 void Menu::ImplSelectWithStart( Menu* pSMenu )
 {
     Menu* pOldStartedFrom = pStartedFrom;
@@ -1157,7 +1158,7 @@ void Menu::ImplSelectWithStart( Menu* pSMenu )
         pOldStartedFrom->pStartedFrom = pOldStartedStarted;
     pStartedFrom = pOldStartedFrom;
 }
-#endif
+//#endif
 
 void Menu::RequestHelp( const HelpEvent& )
 {
@@ -1958,10 +1959,15 @@ sal_Bool Menu::GetItemImageMirrorMode( sal_uInt16 nItemId ) const
 
 void Menu::SetItemCommand( sal_uInt16 nItemId, const String& rCommand )
 {
-    MenuItemData* pData = pItemList->GetData( nItemId );
+    size_t        nPos;
+    MenuItemData* pData = pItemList->GetData( nItemId, nPos );
 
     if ( pData )
         pData->aCommandStr = rCommand;
+
+    // update native menu
+    if( ImplGetSalMenu() && pData->pSalMenuItem )
+        ImplGetSalMenu()->SetItemCommand( nPos, pData->pSalMenuItem, rCommand );
 }
 
 const XubString& Menu::GetItemCommand( sal_uInt16 nItemId ) const
@@ -3238,6 +3244,15 @@ void Menu::HighlightItem( sal_uInt16 nItemPos )
     }
 }
 
+void Menu::Freeze() {
+    SalMenu *pSalMenu = ImplGetSalMenu();
+
+    if ( pSalMenu ) {
+        pSalMenu->Freeze();
+    }
+}
+
+
 // -----------
 // - MenuBar -
 // -----------
diff --git a/vcl/unx/gtk/app/gtkinst.cxx b/vcl/unx/gtk/app/gtkinst.cxx
index 845e2fc..6c9e198 100644
--- a/vcl/unx/gtk/app/gtkinst.cxx
+++ b/vcl/unx/gtk/app/gtkinst.cxx
@@ -38,6 +38,7 @@
 #include <unx/gtk/gtkobject.hxx>
 #include <unx/gtk/atkbridge.hxx>
 #include <unx/gtk/gtkprn.hxx>
+#include <unx/gtk/gtksalmenu.hxx>
 #include <headless/svpvd.hxx>
 #include <headless/svpbmp.hxx>
 #include <vcl/apptypes.hxx>
@@ -518,6 +519,34 @@ SalBitmap* GtkInstance::CreateSalBitmap()
 #endif
 }
 
+SalMenu* GtkInstance::CreateMenu( sal_Bool bMenuBar, Menu* pVCLMenu )
+{
+    GtkSalMenu *pSalMenu = new GtkSalMenu( bMenuBar );
+    pSalMenu->SetMenu( pVCLMenu );
+
+    return static_cast<SalMenu*>( pSalMenu );
+}
+
+void GtkInstance::DestroyMenu( SalMenu* pMenu )
+{
+    (void)pMenu;
+    delete pMenu;
+//    OSL_ENSURE( pMenu == 0, "DestroyMenu called with non-native menus" );
+}
+
+SalMenuItem* GtkInstance::CreateMenuItem( const SalItemParams* pItemData )
+{
+    GtkSalMenuItem *pMenuItem = new GtkSalMenuItem( pItemData );
+    return static_cast<SalMenuItem*>( pMenuItem );
+}
+
+void GtkInstance::DestroyMenuItem( SalMenuItem* pItem )
+{
+    (void)pItem;
+    delete pItem;
+//    OSL_ENSURE( pItem == 0, "DestroyMenu called with non-native menus" );
+}
+
 SalTimer* GtkInstance::CreateSalTimer()
 {
     GtkSalTimer *pTimer = new GtkSalTimer();
diff --git a/vcl/unx/gtk/window/gloactiongroup.cxx b/vcl/unx/gtk/window/gloactiongroup.cxx
new file mode 100644
index 0000000..1a0e88f
--- /dev/null
+++ b/vcl/unx/gtk/window/gloactiongroup.cxx
@@ -0,0 +1,441 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/*
+ * Copyright © 2011 Canonical Ltd.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Author: Antonio Fernández <antonio.fernandez@aentos.es>
+ */
+
+#include <unx/gtk/gloactiongroup.h>
+
+#include <unx/gtk/gtkinst.hxx>
+#include <unx/gtk/gtkframe.hxx>
+#include <unx/gtk/gtksalmenu.hxx>
+#include <vcl/menu.hxx>
+
+#include <stdio.h>
+#include <iostream>
+
+using namespace std;
+
+/*
+ * GLOAction
+ */
+
+#define G_TYPE_LO_ACTION                                (g_lo_action_get_type ())
+#define G_LO_ACTION(inst)                               (G_TYPE_CHECK_INSTANCE_CAST ((inst),                     \
+                                                         G_TYPE_LO_ACTION, GLOAction))
+#define G_IS_LO_ACTION(inst)                            (G_TYPE_CHECK_INSTANCE_TYPE ((inst),                     \
+                                                         G_TYPE_LO_ACTION))
+
+struct _GLOAction
+{
+    GObject         parent_instance;
+
+    GtkSalMenuItem* item;               // A pointer to the menu item.
+    gboolean        enabled;            // TRUE if action is enabled, FALSE otherwise.
+    GVariantType*   parameter_type;     // A GVariantType with the action parameter type.
+    GVariantType*   state_type;         // A GVariantType with item state type
+    GVariant*       state_hint;         // A GVariant with state hints.
+    GVariant*       state;              // A GVariant with current item state
+};
+
+typedef GObjectClass GLOActionClass;
+typedef struct _GLOAction GLOAction;
+
+G_DEFINE_TYPE (GLOAction, g_lo_action, G_TYPE_OBJECT);
+
+GLOAction*
+g_lo_action_new (void)
+{
+    return G_LO_ACTION (g_object_new (G_TYPE_LO_ACTION, NULL));
+}
+
+static void
+g_lo_action_init (GLOAction *action)
+{
+    action->item = NULL;
+    action->enabled = TRUE;
+    action->parameter_type = NULL;
+    action->state_type = NULL;
+    action->state_hint = NULL;
+    action->state = NULL;
+}
+
+static void
+g_lo_action_finalize (GObject *object)
+{
+    GLOAction* action = G_LO_ACTION(object);
+
+    action->item = NULL;
+
+    if (action->parameter_type)
+        g_variant_type_free (action->parameter_type);
+
+    if (action->state_type)
+        g_variant_type_free (action->state_type);
+
+    if (action->state_hint)
+        g_variant_unref (action->state_hint);
+
+    if (action->state)
+        g_variant_unref (action->state);
+
+    G_OBJECT_CLASS (g_lo_action_parent_class)->finalize (object);
+}
+
+static void
+g_lo_action_class_init (GLOActionClass *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS(klass);
+
+    object_class->finalize = g_lo_action_finalize;
+}
+
+/*
+ * GLOActionGroup
+ */
+
+struct _GLOActionGroupPrivate
+{
+    GHashTable *table;  /* string -> GtkSalMenuItem* */
+};
+
+static void g_lo_action_group_iface_init (GActionGroupInterface *);
+
+G_DEFINE_TYPE_WITH_CODE (GLOActionGroup,
+    g_lo_action_group, G_TYPE_OBJECT,
+    G_IMPLEMENT_INTERFACE (G_TYPE_ACTION_GROUP,
+                           g_lo_action_group_iface_init));
+
+static gchar **
+g_lo_action_group_list_actions (GActionGroup *group)
+{
+    GLOActionGroup *loGroup = G_LO_ACTION_GROUP (group);
+    GHashTableIter iter;
+    gint n, i = 0;
+    gchar **keys;
+    gpointer key;
+
+    n = g_hash_table_size (loGroup->priv->table);
+    keys = g_new (gchar *, n + 1);
+
+    g_hash_table_iter_init (&iter, loGroup->priv->table);
+    while (g_hash_table_iter_next (&iter, &key, NULL))
+        keys[i++] = g_strdup ((gchar*) key);
+    g_assert_cmpint (i, ==, n);
+    keys[n] = NULL;
+
+    return keys;
+}
+
+static gboolean
+g_lo_action_group_query_action (GActionGroup        *group,
+                                const gchar         *action_name,
+                                gboolean            *enabled,
+                                const GVariantType **parameter_type,
+                                const GVariantType **state_type,
+                                GVariant           **state_hint,
+                                GVariant           **state)
+{
+    GLOActionGroup *lo_group = G_LO_ACTION_GROUP (group);
+    GLOAction* action;
+
+    action = G_LO_ACTION (g_hash_table_lookup (lo_group->priv->table, action_name));
+
+    if (action == NULL)
+        return FALSE;
+
+    if (enabled)
+        *enabled = action->enabled;
+
+    if (parameter_type) {
+        *parameter_type = action->parameter_type;
+    }
+
+    if (state_type) {
+        *state_type = action->state_type;
+    }
+
+    if (state_hint) {
+        *state_hint = (action->state_hint) ? g_variant_ref(action->state_hint) : NULL;
+    }
+
+    if (state) {
+        *state = (action->state) ? g_variant_ref(action->state) : NULL;
+    }
+
+    return TRUE;
+}
+
+static void
+g_lo_action_group_change_state (GActionGroup *group,
+                                const gchar  *action_name,
+                                GVariant     *value)
+{
+    if (!action_name || !value)
+        return;
+
+    GLOActionGroup* lo_group = G_LO_ACTION_GROUP (group);
+
+    GLOAction* action = G_LO_ACTION (g_hash_table_lookup (lo_group->priv->table, action_name));
+
+    if (action == NULL)
+        return;
+
+    if (action->state_type == NULL)
+        action->state_type = g_variant_type_copy(g_variant_get_type(value));
+
+    g_return_if_fail (g_variant_is_of_type(value, action->state_type) == TRUE);
+
+    if (action->state)
+        g_variant_unref(action->state);
+
+    action->state = g_variant_take_ref(value);
+
+    g_action_group_action_state_changed(group, action_name, value);
+}
+
+static void
+g_lo_action_group_activate (GActionGroup *group,
+                            const gchar  *action_name,
+                            GVariant     *parameter)
+{
+    GTK_YIELD_GRAB();
+
+    GLOActionGroup *loGroup = G_LO_ACTION_GROUP (group);
+    GLOAction* action = G_LO_ACTION (g_hash_table_lookup (loGroup->priv->table, action_name));
+    GtkSalMenuItem *pSalMenuItem = action->item;
+
+    if (pSalMenuItem == NULL || pSalMenuItem->mpSubMenu )
+        return;
+
+    const GtkSalFrame *pFrame = pSalMenuItem->mpParentMenu ? pSalMenuItem->mpParentMenu->GetFrame() : NULL;
+
+    if ( pFrame && !pFrame->GetParent() ) {
+        ((PopupMenu*) pSalMenuItem->mpVCLMenu)->SetSelectedEntry( pSalMenuItem->mnId );
+        SalMenuEvent aMenuEvt( pSalMenuItem->mnId, pSalMenuItem->mpVCLMenu );
+        pFrame->CallCallback( SALEVENT_MENUCOMMAND, &aMenuEvt );
+    }
+    else if ( pSalMenuItem->mpVCLMenu )
+    {
+        // if an item from submenu was selected. the corresponding Window does not exist because
+        // we use native popup menus, so we have to set the selected menuitem directly
+        // incidentally this of course works for top level popup menus, too
+        PopupMenu * pPopupMenu = dynamic_cast<PopupMenu *>(pSalMenuItem->mpVCLMenu);
+        if( pPopupMenu )
+        {
+            // FIXME: revise this ugly code
+
+            // select handlers in vcl are dispatch on the original menu
+            // if not consumed by the select handler of the current menu
+            // however since only the starting menu ever came into Execute
+            // the hierarchy is not build up. Workaround this by getting
+            // the menu it should have been
+
+            // get started from hierarchy in vcl menus
+            GtkSalMenu* pParentMenu = pSalMenuItem->mpParentMenu;
+            Menu* pCurMenu = pSalMenuItem->mpVCLMenu;
+            while( pParentMenu && pParentMenu->GetMenu() )
+            {
+                pCurMenu = pParentMenu->GetMenu();
+                pParentMenu = pParentMenu->GetParentSalMenu();
+            }
+
+            pPopupMenu->SetSelectedEntry( pSalMenuItem->mnId );
+            pPopupMenu->ImplSelectWithStart( pCurMenu );
+        }
+        else
+        {
+            OSL_FAIL( "menubar item without frame !" );
+        }
+    }
+}
+
+void
+g_lo_action_group_insert (GLOActionGroup *group,
+                          const gchar    *action_name,
+                          gpointer        action_info)
+{
+    g_lo_action_group_insert_stateful (group, action_name, action_info, NULL, NULL, NULL, NULL);
+}
+
+void
+g_lo_action_group_insert_stateful (GLOActionGroup     *group,
+                                   const gchar        *action_name,
+                                   gpointer            action_info,
+                                   const GVariantType *parameter_type,
+                                   const GVariantType *state_type,
+                                   GVariant           *state_hint,
+                                   GVariant           *state)
+{
+    g_return_if_fail (G_IS_LO_ACTION_GROUP (group));
+
+    GLOAction* old_action = G_LO_ACTION (g_hash_table_lookup (group->priv->table, action_name));
+
+    if (old_action == NULL || old_action->item != action_info)
+    {
+        if (old_action != NULL)
+            g_action_group_action_removed (G_ACTION_GROUP (group), action_name);
+
+        GLOAction* action = g_lo_action_new();
+
+        g_hash_table_insert (group->priv->table, g_strdup (action_name), action);
+
+        action->item = static_cast< GtkSalMenuItem* >( action_info );
+
+        if (parameter_type)
+            action->parameter_type = (GVariantType*) parameter_type;
+
+        if (state_type)
+            action->state_type = (GVariantType*) state_type;
+
+        if (state_hint)
+            action->state_hint = g_variant_take_ref (state_hint);
+
+        if (state)
+            action->state = g_variant_take_ref (state);
+
+        g_action_group_action_added (G_ACTION_GROUP (group), action_name);
+    }
+}
+
+static void
+g_lo_action_group_finalize (GObject *object)
+{
+    GLOActionGroup *lo_group = G_LO_ACTION_GROUP (object);
+
+    g_hash_table_unref (lo_group->priv->table);
+
+    G_OBJECT_CLASS (g_lo_action_group_parent_class)->finalize (object);
+}
+
+static void
+g_lo_action_group_init (GLOActionGroup *group)
+{
+    group->priv = G_TYPE_INSTANCE_GET_PRIVATE (group,
+                                                 G_TYPE_LO_ACTION_GROUP,
+                                                 GLOActionGroupPrivate);
+    group->priv->table = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                                  g_free, g_object_unref);
+}
+
+static void
+g_lo_action_group_class_init (GLOActionGroupClass *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+    object_class->finalize = g_lo_action_group_finalize;
+
+    g_type_class_add_private (klass, sizeof (GLOActionGroupPrivate));
+}
+
+static void
+g_lo_action_group_iface_init (GActionGroupInterface *iface)
+{
+    iface->list_actions = g_lo_action_group_list_actions;
+    iface->query_action = g_lo_action_group_query_action;
+    iface->change_action_state = g_lo_action_group_change_state;
+    iface->activate_action = g_lo_action_group_activate;
+}
+
+GLOActionGroup *
+g_lo_action_group_new (void)
+{
+    return G_LO_ACTION_GROUP( g_object_new (G_TYPE_LO_ACTION_GROUP, NULL) );
+}
+
+void
+g_lo_action_group_set_action_enabled (GLOActionGroup *group,
+                                      const gchar    *action_name,
+                                      gboolean        enabled)
+{
+    g_return_if_fail (G_IS_LO_ACTION_GROUP (group));
+    g_return_if_fail (action_name != NULL);
+
+    GLOAction* action = G_LO_ACTION (g_hash_table_lookup (group->priv->table, action_name));
+
+    if (action == NULL)
+        return;
+
+    action->enabled = enabled;
+
+    g_action_group_action_enabled_changed(G_ACTION_GROUP(group),
+                                          action_name,
+                                          enabled);
+}
+
+gpointer
+g_lo_action_group_get_action_item (GLOActionGroup *group,
+                                   const gchar    *action_name)
+{
+    g_return_val_if_fail (G_IS_LO_ACTION_GROUP (group), NULL);
+    g_return_val_if_fail (action_name != NULL, NULL);
+
+    GLOAction* action = G_LO_ACTION (g_hash_table_lookup (group->priv->table, action_name));
+
+    return (action != NULL) ? action->item : NULL;
+}
+
+void
+g_lo_action_group_remove (GLOActionGroup *group,
+                          const gchar    *action_name)
+{
+    g_return_if_fail (G_IS_LO_ACTION_GROUP (group));
+
+    if (action_name != NULL)
+    {
+        g_action_group_action_removed (G_ACTION_GROUP (group), action_name);
+        g_hash_table_remove (group->priv->table, action_name);
+    }
+}
+
+void
+g_lo_action_group_clear (GLOActionGroup  *group)
+{
+    g_return_if_fail (G_IS_LO_ACTION_GROUP (group));
+
+    GList* keys = g_hash_table_get_keys (group->priv->table);
+
+    for (GList* element = g_list_first (keys); element != NULL; element = g_list_next (element))
+    {
+        g_lo_action_group_remove (group, (gchar*) element->data);
+    }
+}
+
+void
+g_lo_action_group_merge (GLOActionGroup *input_group,
+                         GLOActionGroup *output_group)
+{
+    g_return_if_fail (G_IS_LO_ACTION_GROUP (input_group));
+    g_return_if_fail (G_IS_LO_ACTION_GROUP (output_group));
+    g_return_if_fail (input_group != NULL);
+    g_return_if_fail (output_group != NULL);
+
+    GHashTableIter iter;
+    gpointer key, value;
+
+    g_hash_table_iter_init (&iter, input_group->priv->table);
+
+    while (g_hash_table_iter_next (&iter, &key, &value))
+    {
+        g_lo_action_group_insert(output_group, (gchar*) key, value);
+    }
+}
+
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/unx/gtk/window/glomenu.cxx b/vcl/unx/gtk/window/glomenu.cxx
new file mode 100644
index 0000000..77be471
--- /dev/null
+++ b/vcl/unx/gtk/window/glomenu.cxx
@@ -0,0 +1,488 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/*
+ * Copyright © 2011 Canonical Ltd.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Author: Antonio Fernández <antonio.fernandez@aentos.es>
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <unx/gtk/gtksalmenu.hxx>
+
+#include <unx/gtk/glomenu.h>
+
+struct _GLOMenu
+{
+    GMenuModel  parent_instance;
+
+    GArray      *items;
+};
+
+typedef GMenuModelClass GLOMenuClass;
+
+G_DEFINE_TYPE (GLOMenu, g_lo_menu, G_TYPE_MENU_MODEL);
+
+struct item
+{
+    GHashTable*     attributes;     // Item attributes.
+    GHashTable*     links;          // Item links.
+};
+
+
+static void
+g_lo_menu_struct_item_init (struct item *menu_item)
+{
+    menu_item->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
+    menu_item->links = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
+}
+
+/* We treat attribute names the same as GSettings keys:
+ * - only lowercase ascii, digits and '-'
+ * - must start with lowercase
+ * - must not end with '-'
+ * - no consecutive '-'
+ * - not longer than 1024 chars
+ */
+static gboolean
+valid_attribute_name (const gchar *name)
+{
+    gint i;
+
+    if (!g_ascii_islower (name[0]))
+        return FALSE;
+
+    for (i = 1; name[i]; i++)
+    {
+        if (name[i] != '-' &&
+                !g_ascii_islower (name[i]) &&
+                !g_ascii_isdigit (name[i]))
+            return FALSE;
+
+        if (name[i] == '-' && name[i + 1] == '-')
+            return FALSE;
+    }
+
+    if (name[i - 1] == '-')
+        return FALSE;
+
+    if (i > 1024)
+        return FALSE;
+
+    return TRUE;
+}
+
+/*
+ * GLOMenu
+ */
+
+static gboolean
+g_lo_menu_is_mutable (GMenuModel *model)
+{
+    // Menu is always mutable.
+    return TRUE;
+}
+
+static gint
+g_lo_menu_get_n_items (GMenuModel *model)
+{
+    GLOMenu *menu = G_LO_MENU (model);
+
+    return menu->items->len;
+}
+
+static void
+g_lo_menu_get_item_attributes (GMenuModel  *model,
+                               gint         position,
+                               GHashTable **table)
+{
+    GLOMenu *menu = G_LO_MENU (model);
+
+    *table = g_hash_table_ref (g_array_index (menu->items, struct item, position).attributes);
+}
+
+static void
+g_lo_menu_get_item_links (GMenuModel  *model,
+                          gint         position,
+                          GHashTable **table)
+{
+    GLOMenu *menu = G_LO_MENU (model);
+
+    *table = g_hash_table_ref (g_array_index (menu->items, struct item, position).links);
+}
+
+void
+g_lo_menu_insert (GLOMenu        *menu,
+                  gint            position,
+                  const gchar    *label)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    if (position < 0 || position > (gint) menu->items->len)
+        position = menu->items->len;
+
+    struct item menu_item;
+
+    g_lo_menu_struct_item_init(&menu_item);
+
+    g_array_insert_val (menu->items, position, menu_item);
+
+    g_lo_menu_set_label (menu, position, label);
+
+    g_menu_model_items_changed (G_MENU_MODEL (menu), position, 0, 1);
+}
+
+void
+g_lo_menu_insert_in_section (GLOMenu        *menu,
+                             gint            section,
+                             gint            position,
+                             const gchar    *label)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+    g_return_if_fail (0 <= section && section < (gint) menu->items->len);
+
+    GLOMenu *model = G_LO_MENU (G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                                ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION));
+
+    g_return_if_fail (model != NULL);
+
+    g_lo_menu_insert (model, position, label);
+}
+
+GLOMenu *
+g_lo_menu_new (void)
+{
+    return G_LO_MENU( g_object_new (G_TYPE_LO_MENU, NULL) );
+}
+
+void
+g_lo_menu_set_attribute_value (GLOMenu     *menu,
+                               gint         position,
+                               const gchar *attribute,
+                               GVariant    *value)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+    g_return_if_fail (attribute != NULL);
+    g_return_if_fail (valid_attribute_name (attribute));
+
+    if (position >= menu->items->len)
+        return;
+
+    struct item menu_item = g_array_index (menu->items, struct item, position);
+
+    if (value != NULL)
+        g_hash_table_insert (menu_item.attributes, g_strdup (attribute), g_variant_ref_sink (value));
+    else
+        g_hash_table_remove (menu_item.attributes, attribute);
+
+}
+
+void
+g_lo_menu_set_label (GLOMenu     *menu,
+                     gint         position,
+                     const gchar *label)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    GVariant *value;
+
+    if (label != NULL)
+        value = g_variant_new_string (label);
+    else
+        value = NULL;
+
+    g_lo_menu_set_attribute_value (menu, position, G_MENU_ATTRIBUTE_LABEL, value);
+}
+
+void
+g_lo_menu_set_label_to_item_in_section (GLOMenu     *menu,
+                                        gint         section,
+                                        gint         position,
+                                        const gchar *label)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    GLOMenu *model = G_LO_MENU (G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                                ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION));
+
+    g_return_if_fail (model != NULL);
+
+    g_lo_menu_set_label (model, position, label);
+
+    // Notify the update.
+    g_menu_model_items_changed (G_MENU_MODEL (model), position, 1, 1);
+}
+
+gchar *
+g_lo_menu_get_label_from_item_in_section (GLOMenu     *menu,
+                                          gint         section,
+                                          gint         position)
+{
+    g_return_val_if_fail (G_IS_LO_MENU (menu), NULL);
+
+    GLOMenu *model = G_LO_MENU (G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                                ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION));
+
+    g_return_val_if_fail (model != NULL, NULL);
+
+    struct item menu_item = g_array_index (model->items, struct item, position);
+
+
+
+    GVariant *current_label = (GVariant*) g_hash_table_lookup (menu_item.attributes, G_MENU_ATTRIBUTE_LABEL);
+
+    if (current_label)
+        return (gchar*) g_variant_get_string (current_label, NULL);
+    else
+        return NULL;
+}
+
+void
+g_lo_menu_set_action_and_target_value (GLOMenu     *menu,
+                                       gint         position,
+                                       const gchar *action,
+                                       GVariant    *target_value)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    GVariant *action_value;
+
+    if (action != NULL)
+    {
+        action_value = g_variant_new_string (action);
+    }
+    else
+    {
+        action_value = NULL;
+        target_value = NULL;
+    }
+
+    g_lo_menu_set_attribute_value (menu, position, G_MENU_ATTRIBUTE_ACTION, action_value);
+    g_lo_menu_set_attribute_value (menu, position, G_MENU_ATTRIBUTE_TARGET, target_value);
+}
+
+void
+g_lo_menu_set_action_and_target_value_to_item_in_section (GLOMenu     *menu,
+                                                          gint         section,
+                                                          gint         position,
+                                                          const gchar *command,
+                                                          GVariant    *target_value)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    struct item menu_item = g_array_index (menu->items, struct item, section);
+
+    GLOMenu *model = G_LO_MENU (g_hash_table_lookup (menu_item.links, G_MENU_LINK_SECTION));
+
+    g_return_if_fail (model != NULL);
+
+    g_lo_menu_set_action_and_target_value (model, position, command, target_value);
+
+    // Notify the update.
+    g_menu_model_items_changed (G_MENU_MODEL (model), position, 1, 1);
+}
+
+void
+g_lo_menu_set_accelerator_to_item_in_section (GLOMenu     *menu,
+                                              gint         section,
+                                              gint         position,
+                                              const gchar *accelerator)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    GMenuModel *model = G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                        ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION);
+
+    g_return_if_fail (model != NULL);
+
+    GVariant *value;
+
+    if (accelerator != NULL)
+        value = g_variant_new_string (accelerator);
+    else
+        value = NULL;
+
+    g_lo_menu_set_attribute_value (G_LO_MENU (model), position, "accel", value);
+
+    // Notify the update.
+    g_menu_model_items_changed (model, position, 1, 1);
+}
+
+void
+g_lo_menu_set_link (GLOMenu     *menu,
+                    gint         position,
+                    const gchar *link,
+                    GMenuModel  *model)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+    g_return_if_fail (link != NULL);
+    g_return_if_fail (valid_attribute_name (link));
+
+    if (position < 0 || position >= (gint) menu->items->len)
+        position = menu->items->len - 1;
+
+    struct item menu_item = g_array_index (menu->items, struct item, position);
+
+    if (model != NULL)
+        g_hash_table_insert (menu_item.links, g_strdup (link), g_object_ref (model));
+    else
+        g_hash_table_remove (menu_item.links, link);
+}
+
+void
+g_lo_menu_insert_section (GLOMenu *menu,
+                          gint position,
+                          const gchar *label,
+                          GMenuModel* section)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+
+    if (position < 0 || position > (gint) menu->items->len)
+        position = menu->items->len;
+
+    struct item menu_item;
+
+    g_lo_menu_struct_item_init(&menu_item);
+
+    g_array_insert_val (menu->items, position, menu_item);
+
+    g_lo_menu_set_label (menu, position, label);
+    g_lo_menu_set_link (menu, position, G_MENU_LINK_SECTION, section);
+
+    g_menu_model_items_changed (G_MENU_MODEL (menu), position, 0, 1);
+}
+
+void
+g_lo_menu_new_section (GLOMenu     *menu,
+                       gint         position,
+                       const gchar *label)
+{
+    GMenuModel *section = G_MENU_MODEL (g_lo_menu_new());
+
+    g_lo_menu_insert_section (menu, position, label, section);
+
+//    g_object_unref (section);
+}
+
+
+
+GLOMenu *
+g_lo_menu_get_section (GLOMenu *menu,
+                       gint section)
+{
+    g_return_val_if_fail (G_IS_LO_MENU (menu), NULL);
+
+    return G_LO_MENU (G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                      ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION));
+}
+
+void
+g_lo_menu_set_submenu_to_item_in_section (GLOMenu    *menu,
+                                          gint        section,
+                                          gint        position,
+                                          GMenuModel *submenu)
+{
+//    puts(__FUNCTION__);
+    g_return_if_fail (G_IS_LO_MENU (menu));
+    g_return_if_fail (0 <= section && section < (gint) menu->items->len);
+
+    GLOMenu *model = G_LO_MENU (G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                                ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION));
+
+    g_return_if_fail (model != NULL);
+
+    g_lo_menu_set_link (model, position, G_MENU_LINK_SUBMENU, submenu);
+}
+
+static void
+g_lo_menu_clear_item (struct item *menu_item)
+{
+    if (menu_item->attributes != NULL)
+        g_hash_table_unref (menu_item->attributes);
+    if (menu_item->links != NULL)
+        g_hash_table_unref (menu_item->links);
+}
+
+void
+g_lo_menu_remove (GLOMenu *menu,
+                  gint     position)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+    g_return_if_fail (0 <= position && position < (gint) menu->items->len);
+
+    g_lo_menu_clear_item (&g_array_index (menu->items, struct item, position));
+    g_array_remove_index (menu->items, position);
+    g_menu_model_items_changed (G_MENU_MODEL (menu), position, 1, 0);
+}
+
+void
+g_lo_menu_remove_from_section (GLOMenu *menu,
+                               gint     section,
+                               gint     position)
+{
+    g_return_if_fail (G_IS_LO_MENU (menu));
+    g_return_if_fail (0 <= section && section < (gint) menu->items->len);
+
+    GLOMenu *model = G_LO_MENU (G_MENU_MODEL_CLASS (g_lo_menu_parent_class)
+                                ->get_item_link (G_MENU_MODEL (menu), section, G_MENU_LINK_SECTION));
+
+    g_return_if_fail (model != NULL);
+
+    g_lo_menu_remove (model, position);
+}
+
+static void
+g_lo_menu_finalize (GObject *object)
+{
+    GLOMenu *menu = G_LO_MENU (object);
+    struct item *items;
+    gint n_items;
+    gint i;
+
+    n_items = menu->items->len;
+    items = (struct item *) g_array_free (menu->items, FALSE);
+    for (i = 0; i < n_items; i++)
+        g_lo_menu_clear_item (&items[i]);
+    g_free (items);
+
+    G_OBJECT_CLASS (g_lo_menu_parent_class)
+            ->finalize (object);
+}
+
+static void
+g_lo_menu_init (GLOMenu *menu)
+{
+    menu->items = g_array_new (FALSE, FALSE, sizeof (struct item));
+}
+
+static void
+g_lo_menu_class_init (GLOMenuClass *klass)
+{
+    GMenuModelClass *model_class = G_MENU_MODEL_CLASS (klass);
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+    object_class->finalize = g_lo_menu_finalize;
+
+    model_class->is_mutable = g_lo_menu_is_mutable;
+    model_class->get_n_items = g_lo_menu_get_n_items;
+    model_class->get_item_attributes = g_lo_menu_get_item_attributes;
+    model_class->get_item_links = g_lo_menu_get_item_links;
+}
+
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/unx/gtk/window/gtksalmenu.cxx b/vcl/unx/gtk/window/gtksalmenu.cxx
new file mode 100644
index 0000000..712f868
--- /dev/null
+++ b/vcl/unx/gtk/window/gtksalmenu.cxx
@@ -0,0 +1,660 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * Copyright © 2011 Canonical Ltd.
+ *
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * licence, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ *
+ * Author: Antonio Fernández <antonio.fernandez@aentos.es>
+ */
+
+#include "unx/gtk/gtksalmenu.hxx"
+
+//#include <gtk/gtk.h>
+#include <unx/gtk/glomenu.h>
+#include <unx/gtk/gloactiongroup.h>
+#include <vcl/menu.hxx>
+#include <unx/gtk/gtkinst.hxx>
+
+#include <iostream>
+
+using namespace std;
+
+//Some menus are special, this is the list of them
+//gboolean
+//isSpecialSubmenu (OUString command)
+//{
+//    const gchar * specialSubmenus[11] = {".uno:CharFontName",
+//                                         ".uno:FontHeight",
+//                                         ".uno:ObjectMenue",
+//                                         ".uno:InsertPageHeader",
+//                                         ".uno:InsertPageFooter",
+//                                         ".uno:ChangeControlType",
+//                                         ".uno:AvailableToolbars",
+//                                         ".uno:ScriptOrganizer",
+//                                         ".uno:RecentFileList",
+//                                         ".uno:AddDirect",
+//                                         ".uno:AutoPilotMenu"};
+
+//    for (gint i = 0; i < 11; i++)
+//    {
+//        if (command.equals (OUString::createFromAscii (specialSubmenus[i])))
+//            return TRUE;
+//    }
+//    return FALSE;
+//}
+
+static void UpdateNativeMenu( GtkSalMenu* pMenu ) {
+    if ( pMenu == NULL )
+        return;
+
+    Menu* pVCLMenu = pMenu->GetMenu();
+
+    for ( sal_uInt16 i = 0; i < pMenu->GetItemCount(); i++ ) {
+        GtkSalMenuItem *pSalMenuItem = pMenu->GetItemAtPos( i );
+        sal_uInt16 nId = pSalMenuItem->mnId;
+
+        if ( pSalMenuItem->mnType == MENUITEM_SEPARATOR )
+            continue;
+
+        String aText = pVCLMenu->GetItemText( nId );
+        String aCommand = pVCLMenu->GetItemCommand( nId );
+        sal_Bool itemEnabled = pVCLMenu->IsItemEnabled( nId );
+        KeyCode nAccelKey = pVCLMenu->GetAccelKey( nId );
+        sal_Bool itemChecked = pVCLMenu->IsItemChecked( nId );
+
+        // Force updating of native menu labels.
+        pMenu->SetItemCommand( i, pSalMenuItem, aCommand );
+        pMenu->SetItemText( i, pSalMenuItem, aText );
+        pMenu->EnableItem( i, itemEnabled );
+        pMenu->SetAccelerator( i, pSalMenuItem, nAccelKey, nAccelKey.GetName( pMenu->GetFrame()->GetWindow() ) );
+        pMenu->CheckItem( i, itemChecked );
+
+        GtkSalMenu* pSubmenu = pSalMenuItem->mpSubMenu;
+
+        if ( pSubmenu && pSubmenu->GetMenu() ) {
+            pSubmenu->GetMenu()->Activate();
+            pSubmenu->GetMenu()->Deactivate();
+            UpdateNativeMenu( pSubmenu );
+        }
+    }
+}
+
+gboolean GenerateMenu(gpointer user_data) {
+    GtkSalMenu* pSalMenu = static_cast< GtkSalMenu* >( user_data );
+
+    UpdateNativeMenu( pSalMenu );
+
+    return TRUE;
+}
+
+void ObjectDestroyedNotify( gpointer data ) {
+    if ( data ) {
+        g_object_unref( data );
+    }
+}
+
+void
+gdk_x11_window_set_utf8_property  (GdkWindow *window,
+                                   const gchar *name,
+                                   const gchar *value)
+{
+  GdkDisplay *display;
+
+  //if (!WINDOW_IS_TOPLEVEL (window))
+    //return;
+
+  display = gdk_window_get_display (window);
+
+  if (value != NULL)
+    {
+      XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
+                       GDK_WINDOW_XID (window),
+                       gdk_x11_get_xatom_by_name_for_display (display, name),
+                       gdk_x11_get_xatom_by_name_for_display (display, "UTF8_STRING"), 8,
+                       PropModeReplace, (guchar *)value, strlen (value));
+    }
+  else
+    {
+      XDeleteProperty (GDK_DISPLAY_XDISPLAY (display),
+                       GDK_WINDOW_XID (window),
+                       gdk_x11_get_xatom_by_name_for_display (display, name));
+    }
+}
+
+GActionGroup* GetActionGroupFromMenubar( GtkSalMenu *pMenu )
+{
+    GtkSalMenu *pSalMenu = pMenu;
+
+    while ( pSalMenu && pSalMenu->GetParentSalMenu() )
+        pSalMenu = pSalMenu->GetParentSalMenu();
+
+    return ( pSalMenu ) ? pSalMenu->GetActionGroup() : NULL;
+}
+
+// FIXME: Check for missing keys. Maybe translating keycodes would be safer...
+rtl::OUString GetGtkKeyName( rtl::OUString keyName )
+{
+    rtl::OUString aGtkKeyName("");
+
+    sal_Int32 nIndex = 0;
+
+    do
+    {
+        rtl::OUString token = keyName.getToken( 0, '+', nIndex );
+
+        if ( token == "Ctrl" ) {
+            aGtkKeyName += "<Control>";
+        } else if ( token == "Alt" ) {
+            aGtkKeyName += "<Alt>";
+        } else if ( token == "Shift" ) {
+            aGtkKeyName += "<Shift>";
+        } else {
+            aGtkKeyName += token;
+        }
+    } while ( nIndex >= 0 );
+
+    return aGtkKeyName;
+}
+
+//GVariant* GetRadioButtonHints( GtkSalMenuItem *pSalMenuItem )
+//{
+//    GVariantBuilder *pBuilder;
+//    GVariant *pHints;
+
+//    pBuilder = g_variant_builder_new( G_VARIANT_TYPE_STRING );
+
+//    Menu* pMenu = pSalMenuItem->mpVCLMenu;
+
+//    gboolean bItemIncluded = FALSE;
+
+//    for ( sal_uInt16 i = 0; i < pMenu->GetItemCount(); i++ )
+//    {
+//        sal_uInt16 nId = pMenu->GetItemId( i );
+//        MenuItemBits itemBits = pMenu->GetItemBits( nId );
+//        MenuItemType itemType = pMenu->GetItemType( nId );
+
+//        if ( itemBits & MIB_RADIOCHECK )
+//        {
+//            rtl::OString aValue = rtl::OUStringToOString( pMenu->GetItemText( nId ), RTL_TEXTENCODING_UTF8 );
+//            g_variant_builder_add( pBuilder, "s", aValue.getStr() );
+
+//            if ( nId == pSalMenuItem->mnId )
+//                bItemIncluded = TRUE;
+//        }
+//        else if ( itemType == MENUITEM_SEPARATOR )
+//        {
+//            if ( bItemIncluded == FALSE )
+//            {
+//                g_variant_builder_clear( pBuilder );
+//            }
+//            else
+//                break;
+//        }
+//    }
+
+//    // Build an array of G_VARIANT_TYPE_STRING.
+//    pHints = g_variant_new ("as", pBuilder);
+//    g_variant_builder_unref ( pBuilder );
+
+//    return pHints;
+//}
+
+/*
+ * GtkSalMenu
+ */
+
+// FIXME: Iterating through the whole list everytime is slow, but works. Some fine tuning would be required here...
+void GtkSalMenu::GetItemSectionAndPosition( unsigned nPos, unsigned *insertSection, unsigned *insertPos )
+{
+    if ( mpVCLMenu == NULL || nPos >= mpVCLMenu->GetItemCount() )
+    {
+        *insertSection = g_menu_model_get_n_items( mpMenuModel ) - 1;
+        *insertPos = MENU_APPEND;
+    }
+    else
+    {
+        unsigned nItem;
+        gint nItemPos;
+
+        for ( nItem = 0, *insertSection = 0, nItemPos = -1; nItem <= nPos; nItem++ )
+        {
+            if ( mpVCLMenu->GetItemType( nItem ) == MENUITEM_SEPARATOR ) {
+                (*insertSection)++;
+                nItemPos = -1;
+            } else
+                nItemPos++;
+        }
+
+        *insertPos = nItemPos;
+    }
+}
+
+GtkSalMenu::GtkSalMenu( sal_Bool bMenuBar ) :
+    mbMenuBar( bMenuBar ),
+    mpVCLMenu( NULL ),
+    mpParentSalMenu( NULL ),
+    mpFrame( NULL ),
+    mpMenuModel( NULL ),
+    mpActionGroup( NULL )
+{
+    mpMenuModel = G_MENU_MODEL( g_lo_menu_new() );
+    g_lo_menu_new_section( G_LO_MENU( mpMenuModel ), 0, NULL);
+}
+
+GtkSalMenu::~GtkSalMenu()
+{
+    if ( mpActionGroup ) {
+        g_lo_action_group_clear( G_LO_ACTION_GROUP( mpActionGroup ) );
+    }
+
+    if ( mbMenuBar ) {
+        g_source_remove_by_user_data( this );
+        g_lo_menu_remove( G_LO_MENU( mpMenuModel ), 0 );
+    } else {
+        g_object_unref( mpMenuModel );
+    }
+
+    maItems.clear();
+}
+
+sal_Bool GtkSalMenu::VisibleMenuBar()
+{
+    return sal_True;
+}
+
+void GtkSalMenu::InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos )
+{
+    GtkSalMenuItem *pItem = static_cast<GtkSalMenuItem*>( pSalMenuItem );
+
+    if ( nPos == MENU_APPEND )
+        maItems.push_back( pItem );
+    else
+        maItems.insert( maItems.begin() + nPos, pItem );
+
+    pItem->mpParentMenu = this;
+
+    if ( pItem->mnType != MENUITEM_SEPARATOR )
+    {
+        unsigned nInsertSection, nInsertPos;
+        GetItemSectionAndPosition( nPos, &nInsertSection, &nInsertPos );
+
+        g_lo_menu_insert_in_section( G_LO_MENU( mpMenuModel ), nInsertSection, nInsertPos, "EMPTY STRING" );
+    }
+    else
+    {
+        g_lo_menu_new_section( G_LO_MENU( mpMenuModel ), MENU_APPEND, NULL );
+    }
+}
+
+void GtkSalMenu::RemoveItem( unsigned nPos )
+{
+    GLOMenu* pMenu = G_LO_MENU( mpMenuModel );
+    GtkSalMenuItem *pItem = maItems[ nPos ];
+
+    // If item is a separator, the last section of the menu is removed.
+    if ( pItem->mnType != MENUITEM_SEPARATOR )
+    {
+        if ( pItem->maCommand ) {
+            GLOActionGroup* pActionGroup = G_LO_ACTION_GROUP( GetActionGroupFromMenubar( this ) );
+
+            if ( pActionGroup != NULL )
+                g_lo_action_group_remove( pActionGroup, pItem->maCommand );
+
+            g_free ( pItem->maCommand );
+            pItem->maCommand = NULL;
+        }
+
+        unsigned nSection, nItemPos;
+        GetItemSectionAndPosition( nPos, &nSection, &nItemPos );
+
+        g_lo_menu_remove_from_section( pMenu, nSection, nItemPos );
+    }
+    else
+    {
+        gint nSection = g_menu_model_get_n_items( mpMenuModel ) - 1;
+
+        if ( nSection > 0 )
+            g_lo_menu_remove( pMenu, nSection );
+    }
+
+    maItems.erase( maItems.begin() + nPos );
+}
+
+void GtkSalMenu::SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos )
+{
+    GtkSalMenuItem *pItem = static_cast< GtkSalMenuItem* >( pSalMenuItem );
+    GtkSalMenu *pGtkSubMenu = static_cast< GtkSalMenu* >( pSubMenu );
+
+    if ( pGtkSubMenu == NULL )
+        return;
+
+    pGtkSubMenu->mpParentSalMenu = this;
+    pItem->mpSubMenu = pGtkSubMenu;
+
+    // Update item in GMenuModel.
+    unsigned nSection, nItemPos;
+    GetItemSectionAndPosition( nPos, &nSection, &nItemPos );
+
+    g_lo_menu_set_submenu_to_item_in_section( G_LO_MENU( mpMenuModel ), nSection, nItemPos, pGtkSubMenu->mpMenuModel );
+}
+
+void GtkSalMenu::SetFrame( const SalFrame* pFrame )
+{
+    mpFrame = static_cast<const GtkSalFrame*>( pFrame );
+
+    GtkWidget *widget = GTK_WIDGET( mpFrame->getWindow() );
+
+    GdkWindow *gdkWindow = gtk_widget_get_window( widget );
+
+    if (gdkWindow) {
+        GLOMenu* pMainMenu = G_LO_MENU( g_object_get_data( G_OBJECT( gdkWindow ), "g-lo-menubar" ) );
+        GLOActionGroup* pActionGroup = G_LO_ACTION_GROUP( g_object_get_data( G_OBJECT( gdkWindow ), "g-lo-action-group" ) );
+
+        if ( pMainMenu && pActionGroup ) {
+            g_lo_menu_remove( pMainMenu, 0 );
+        } else {
+            pMainMenu = g_lo_menu_new();
+            pActionGroup = g_lo_action_group_new();
+
+            g_object_set_data_full( G_OBJECT( gdkWindow ), "g-lo-menubar", pMainMenu, ObjectDestroyedNotify );
+            g_object_set_data_full( G_OBJECT( gdkWindow ), "g-lo-action-group", pActionGroup, ObjectDestroyedNotify );
+
+            XLIB_Window windowId = GDK_WINDOW_XID( gdkWindow );
+
+            gchar* aDBusPath = g_strdup_printf("/window/%lu", windowId);
+            gchar* aDBusWindowPath = g_strdup_printf( "/window/%lu", windowId );
+            gchar* aDBusMenubarPath = g_strdup_printf( "/window/%lu/menus/menubar", windowId );
+
+            // Get a DBus session connection.
+            GDBusConnection* pSessionBus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);
+            if(!pSessionBus) puts ("Failed to get DBus session connection");
+
+            // Publish the menu.
+            if ( aDBusMenubarPath ) {
+                sal_uInt16 menubarId = g_dbus_connection_export_menu_model (pSessionBus, aDBusMenubarPath, G_MENU_MODEL( pMainMenu ), NULL);
+                if(!menubarId) puts("Failed to export menubar");
+            }
+
+            if ( aDBusPath ) {
+                sal_uInt16 actionGroupId = g_dbus_connection_export_action_group( pSessionBus, aDBusPath, G_ACTION_GROUP( pActionGroup ), NULL);
+                if(!actionGroupId) puts("Failed to export action group");
+            }
+
+            // Set window properties.
+            gdk_x11_window_set_utf8_property ( gdkWindow, "_GTK_UNIQUE_BUS_NAME", g_dbus_connection_get_unique_name( pSessionBus ) );
+            gdk_x11_window_set_utf8_property ( gdkWindow, "_GTK_APPLICATION_OBJECT_PATH", "" );
+            gdk_x11_window_set_utf8_property ( gdkWindow, "_GTK_WINDOW_OBJECT_PATH", aDBusWindowPath );
+            gdk_x11_window_set_utf8_property ( gdkWindow, "_GTK_MENUBAR_OBJECT_PATH", aDBusMenubarPath );
+
+            g_free( aDBusPath );
+            g_free( aDBusWindowPath );
+            g_free( aDBusMenubarPath );
+        }
+
+        // Menubar has only one section, so we put it on the exported menu.
+        g_lo_menu_insert_section( pMainMenu, 0, NULL, mpMenuModel );
+        mpActionGroup = G_ACTION_GROUP( pActionGroup );
+
+//        UpdateNativeMenu( this );
+//        UpdateNativeMenu( this );
+
+        // Refresh the menu every second.
+        // This code is a workaround until required modifications in Gtk+ are available.
+        g_timeout_add_seconds( 1, GenerateMenu, this );
+    }
+}
+
+const GtkSalFrame* GtkSalMenu::GetFrame() const
+{
+    const GtkSalMenu* pMenu = this;
+    while( pMenu && ! pMenu->mpFrame )
+        pMenu = pMenu->mpParentSalMenu;
+    return pMenu ? pMenu->mpFrame : NULL;
+}
+
+void GtkSalMenu::CheckItem( unsigned nPos, sal_Bool bCheck )
+{
+    GtkSalMenuItem* pItem = maItems[ nPos ];
+
+    if ( pItem->mpSubMenu )
+        return;
+
+    if ( pItem->maCommand == NULL || g_strcmp0( pItem->maCommand, "" ) == 0 )
+        return;
+
+    GActionGroup* pActionGroup = GetActionGroupFromMenubar( this );
+
+    if ( !pActionGroup )
+        return;
+
+    GVariant *pCheckValue = NULL;
+    gboolean bCheckedValue = ( bCheck == sal_True ) ? TRUE : FALSE;
+
+    // FIXME: Why pItem->mnBits differs from GetItemBits value?
+    MenuItemBits bits = pItem->mpVCLMenu->GetItemBits( pItem->mnId );
+
+    if ( bits & MIB_CHECKABLE ) {
+        GVariant* pState = g_action_group_get_action_state( pActionGroup, pItem->maCommand );
+        gboolean bCurrentState = g_variant_get_boolean( pState );
+
+        if ( bCurrentState != bCheck )
+            pCheckValue = g_variant_new_boolean( bCheckedValue );
+    }
+    else if ( bits & MIB_RADIOCHECK )
+    {
+        GVariant* pState = g_action_group_get_action_state( pActionGroup, pItem->maCommand );
+        gchar* aCurrentState = (gchar*) g_variant_get_string( pState, NULL );
+        gboolean bCurrentState = g_strcmp0( aCurrentState, "" ) != 0;
+
+        if ( bCurrentState != bCheck )
+            pCheckValue = (bCheckedValue) ? g_variant_new_string( pItem->maCommand ) : g_variant_new_string( "" );
+    }
+
+    if ( pCheckValue )
+        g_action_group_change_action_state( pActionGroup, pItem->maCommand, pCheckValue );
+}
+
+void GtkSalMenu::EnableItem( unsigned nPos, sal_Bool bEnable )
+{
+    GLOActionGroup* pActionGroup = G_LO_ACTION_GROUP( GetActionGroupFromMenubar( this ) );
+
+    if ( pActionGroup == NULL )
+        return;
+
+    sal_uInt16 nId = mpVCLMenu->GetItemId( nPos );
+    rtl::OUString aOUCommand = mpVCLMenu->GetItemCommand( nId );
+
+    if ( aOUCommand == NULL || aOUCommand.isEmpty() )
+        return;
+
+    gchar* aCommand = (gchar*) rtl::OUStringToOString( aOUCommand, RTL_TEXTENCODING_UTF8 ).getStr();
+
+    gboolean bItemEnabled = (bEnable == sal_True) ? TRUE : FALSE;
+
+    if ( g_action_group_get_action_enabled( G_ACTION_GROUP( pActionGroup ), aCommand ) != bItemEnabled )
+        g_lo_action_group_set_action_enabled( pActionGroup, aCommand, bItemEnabled );
+}
+
+void GtkSalMenu::SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const rtl::OUString& rText )
+{
+    // Replace the "~" character with "_".
+    rtl::OUString aText = rText.replace( '~', '_' );
+    rtl::OString aConvertedText = OUStringToOString( aText, RTL_TEXTENCODING_UTF8 );
+
+    unsigned nSection, nItemPos;
+    GetItemSectionAndPosition( nPos, &nSection, &nItemPos );
+
+    // Update item text only when necessary.
+    sal_Bool bSetLabel = sal_True;
+
+    GtkSalMenuItem* pItem = static_cast< GtkSalMenuItem* >( pSalMenuItem );
+
+    // FIXME: It would be better retrieving the label from the menu itself, but it currently crashes the app.
+    if ( pItem->maLabel && g_strcmp0( pItem->maLabel, aConvertedText.getStr() ) == 0 )
+        bSetLabel = sal_False;
+
+    if ( bSetLabel == sal_True ) {
+        if ( pItem->maLabel )
+            g_free( pItem->maLabel );
+
+        pItem->maLabel = g_strdup( aConvertedText.getStr() );
+        g_lo_menu_set_label_to_item_in_section( G_LO_MENU( mpMenuModel ), nSection, nItemPos, pItem->maLabel );
+    }
+}
+
+void GtkSalMenu::SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage)
+{
+}
+
+void GtkSalMenu::SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const rtl::OUString& rKeyName )
+{
+    GtkSalMenuItem *pItem = static_cast< GtkSalMenuItem* >( pSalMenuItem );
+
+    if ( rKeyName.isEmpty() )
+        return;
+
+    rtl::OString aAccelerator = rtl::OUStringToOString( GetGtkKeyName( rKeyName ), RTL_TEXTENCODING_UTF8 );
+
+    unsigned nSection, nItemPos;
+    GetItemSectionAndPosition( nPos, &nSection, &nItemPos );
+
+    sal_Bool bSetAccel = sal_True;
+
+    if ( pItem->maAccel && g_strcmp0( pItem->maAccel, aAccelerator.getStr() ) == 0 )
+            bSetAccel = sal_False;
+
+    if ( bSetAccel == sal_True ) {
+        if (pItem->maAccel)
+            g_free( pItem->maAccel );
+
+        pItem->maAccel = g_strdup( aAccelerator.getStr() );
+        g_lo_menu_set_accelerator_to_item_in_section ( G_LO_MENU( mpMenuModel ), nSection, nItemPos, pItem->maAccel );
+    }
+}
+
+void GtkSalMenu::SetItemCommand( unsigned nPos, SalMenuItem* pSalMenuItem, const rtl::OUString& aCommandStr )
+{
+    GtkSalMenuItem* pItem = static_cast< GtkSalMenuItem* >( pSalMenuItem );
+
+    if ( pItem->mnType == MENUITEM_SEPARATOR ||
+         pItem->mpVCLMenu->GetPopupMenu( pItem->mnId ) != NULL ||
+         aCommandStr.isEmpty() )
+        return;
+
+    gchar* aCommand = (gchar*) rtl::OUStringToOString( aCommandStr, RTL_TEXTENCODING_UTF8 ).getStr();
+
+    GLOActionGroup* pActionGroup = G_LO_ACTION_GROUP( GetActionGroupFromMenubar( this ) );
+    if ( pActionGroup == NULL )
+        return;
+
+    GVariant *pTarget = NULL;
+
+    if ( g_action_group_has_action( G_ACTION_GROUP( pActionGroup ), aCommand ) == FALSE ) {
+        gboolean bChecked = ( pItem->mpVCLMenu->IsItemChecked( pItem->mnId ) ) ? TRUE : FALSE;
+
+        // FIXME: Why pItem->mnBits differs from GetItemBits value?
+        MenuItemBits bits = pItem->mpVCLMenu->GetItemBits( pItem->mnId );
+
+        if ( bits & MIB_CHECKABLE )
+        {
+            // Item is a checkmark button.
+            GVariantType* pStateType = g_variant_type_new( (gchar*) G_VARIANT_TYPE_BOOLEAN );
+            GVariant* pState = g_variant_new_boolean( bChecked );
+
+            g_lo_action_group_insert_stateful( pActionGroup, aCommand, pItem, NULL, pStateType, NULL, pState );
+        }
+        else if ( bits & MIB_RADIOCHECK )
+        {
+            // Item is a radio button.
+            GVariantType* pParameterType = g_variant_type_new( (gchar*) G_VARIANT_TYPE_STRING );
+            GVariantType* pStateType = g_variant_type_new( (gchar*) G_VARIANT_TYPE_STRING );
+            //        GVariant* pStateHint = GetRadioButtonHints( pItem );
+            GVariant* pState = g_variant_new_string( "" );
+            pTarget = g_variant_new_string( aCommand );
+
+            g_lo_action_group_insert_stateful( pActionGroup, aCommand, pItem, pParameterType, pStateType, NULL, pState );
+        }
+        else
+        {
+            // Item is not special, so insert a stateless action.
+            g_lo_action_group_insert( pActionGroup, aCommand, pItem );
+        }
+    }
+
+    // Menu item is not updated unless it's necessary.
+    if ( ( pItem->maCommand != NULL ) && ( g_strcmp0( pItem->maCommand, aCommand ) == 0 ) )
+        return;
+
+    if ( pItem->maCommand != NULL )
+        g_free( pItem->maCommand );
+
+    pItem->maCommand = g_strdup( aCommand );
+
+    unsigned nSection, nItemPos;
+    GetItemSectionAndPosition( nPos, &nSection, &nItemPos );
+
+    gchar* aItemCommand = g_strconcat("win.", aCommand, NULL );
+
+    if ( pItem->maCommand )
+        g_free( pItem->maCommand );
+
+    pItem->maCommand = g_strdup( aCommand );
+
+    g_lo_menu_set_action_and_target_value_to_item_in_section( G_LO_MENU( mpMenuModel ), nSection, nItemPos, aItemCommand, pTarget );
+
+    g_free( aItemCommand );
+}
+
+void GtkSalMenu::GetSystemMenuData( SystemMenuData* pData )
+{
+}
+
+void GtkSalMenu::Freeze()
+{
+}
+
+// =======================================================================
+
+/*
+ * GtkSalMenuItem
+ */
+
+GtkSalMenuItem::GtkSalMenuItem( const SalItemParams* pItemData ) :
+    mnId( pItemData->nId ),
+    mnBits( pItemData->nBits ),
+    mnType( pItemData->eType ),
+    mpVCLMenu( pItemData->pMenu ),
+    mpParentMenu( NULL ),
+    mpSubMenu( NULL ),
+    maCommand( NULL ),
+    maLabel( NULL ),
+    maAccel( NULL )
+{
+}
+
+GtkSalMenuItem::~GtkSalMenuItem()
+{
+    if ( maCommand )
+        g_free( maCommand );
+
+    if ( maLabel )
+        g_free( maLabel );
+
+    if ( maAccel )
+        g_free( maAccel );
+}
+
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/vcl/unx/gtk3/window/gtk3gloactiongroup.cxx b/vcl/unx/gtk3/window/gtk3gloactiongroup.cxx
new file mode 100644
index 0000000..14a2bbb
--- /dev/null
+++ b/vcl/unx/gtk3/window/gtk3gloactiongroup.cxx
@@ -0,0 +1,2 @@
+
+#include "../../gtk/window/gloactiongroup.cxx"
diff --git a/vcl/unx/gtk3/window/gtk3glomenu.cxx b/vcl/unx/gtk3/window/gtk3glomenu.cxx
new file mode 100644
index 0000000..3736ac4
--- /dev/null
+++ b/vcl/unx/gtk3/window/gtk3glomenu.cxx
@@ -0,0 +1,2 @@
+
+#include "../../gtk/window/glomenu.cxx"
diff --git a/vcl/unx/gtk3/window/gtk3gtksalmenu.cxx b/vcl/unx/gtk3/window/gtk3gtksalmenu.cxx
new file mode 100644
index 0000000..d6c7abe
--- /dev/null
+++ b/vcl/unx/gtk3/window/gtk3gtksalmenu.cxx
@@ -0,0 +1,2 @@
+
+#include "../../gtk/window/gtksalmenu.cxx"
